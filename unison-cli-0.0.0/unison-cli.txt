-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package unison-cli
@version 0.0.0

module Compat
onWindows :: Bool

-- | Constructs a default interrupt handler which builds an interrupt
--   handler which throws a UserInterrupt exception to the thread in which
--   the setup was initially called.
defaultInterruptHandler :: IO (IO ())

-- | Replaces any existing interrupt handlers with the provided IO action
--   while the provided action is running, restoring any existing handlers
--   afterwards.
withInterruptHandler :: IO () -> IO a -> IO a

module Unison.Auth.Types
data DiscoveryDoc
DiscoveryDoc :: URI -> URI -> URI -> URI -> DiscoveryDoc
[$sel:issuer:DiscoveryDoc] :: DiscoveryDoc -> URI
[$sel:authorizationEndpoint:DiscoveryDoc] :: DiscoveryDoc -> URI
[$sel:tokenEndpoint:DiscoveryDoc] :: DiscoveryDoc -> URI
[$sel:userInfoEndpoint:DiscoveryDoc] :: DiscoveryDoc -> URI
data Tokens
Tokens :: AccessToken -> Maybe IDToken -> Maybe RefreshToken -> TokenType -> NominalDiffTime -> Scopes -> Tokens
[$sel:accessToken:Tokens] :: Tokens -> AccessToken
[$sel:idToken:Tokens] :: Tokens -> Maybe IDToken
[$sel:refreshToken:Tokens] :: Tokens -> Maybe RefreshToken
[$sel:tokenType:Tokens] :: Tokens -> TokenType
[$sel:expiresIn:Tokens] :: Tokens -> NominalDiffTime
[$sel:scopes:Tokens] :: Tokens -> Scopes
data Credentials
Credentials :: Map ProfileName (Map CodeserverId CodeserverCredentials) -> ProfileName -> Credentials
[$sel:credentials:Credentials] :: Credentials -> Map ProfileName (Map CodeserverId CodeserverCredentials)
[$sel:activeProfile:Credentials] :: Credentials -> ProfileName
type Code = Text
type AccessToken = Text
type RefreshToken = Text
type IDToken = Text
type OAuthState = ByteString
type PKCEVerifier = ByteString
type PKCEChallenge = ByteString
type ProfileName = Text
data CredentialFailure
ReauthRequired :: CodeserverId -> CredentialFailure
CredentialParseFailure :: FilePath -> Text -> CredentialFailure
InvalidDiscoveryDocument :: URI -> Text -> CredentialFailure
InvalidJWT :: Text -> CredentialFailure
RefreshFailure :: Text -> CredentialFailure
InvalidTokenResponse :: URI -> Text -> CredentialFailure
InvalidHost :: CodeserverURI -> CredentialFailure

-- | Credentials for a specific codeserver
data CodeserverCredentials
CodeserverCredentials :: Tokens -> URI -> CodeserverCredentials
[$sel:tokens:CodeserverCredentials] :: CodeserverCredentials -> Tokens
[$sel:discoveryURI:CodeserverCredentials] :: CodeserverCredentials -> URI
getCodeserverCredentials :: CodeserverId -> Credentials -> Either CredentialFailure CodeserverCredentials
setCodeserverCredentials :: CodeserverId -> CodeserverCredentials -> Credentials -> Credentials
codeserverCredentials :: URI -> Tokens -> CodeserverCredentials
emptyCredentials :: Credentials
instance GHC.Exception.Type.Exception Unison.Auth.Types.CredentialFailure
instance GHC.Classes.Eq Unison.Auth.Types.CredentialFailure
instance GHC.Show.Show Unison.Auth.Types.CredentialFailure
instance GHC.Classes.Ord Unison.Auth.Types.Scopes
instance GHC.Classes.Eq Unison.Auth.Types.Scopes
instance GHC.Show.Show Unison.Auth.Types.Scopes
instance GHC.Show.Show Unison.Auth.Types.DiscoveryDoc
instance GHC.Show.Show Unison.Auth.Types.Tokens
instance GHC.Classes.Eq Unison.Auth.Types.Tokens
instance GHC.Classes.Eq Unison.Auth.Types.CodeserverCredentials
instance GHC.Classes.Eq Unison.Auth.Types.Credentials
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.Credentials
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.Credentials
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.CodeserverCredentials
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.CodeserverCredentials
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.URIParam
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.DiscoveryDoc
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.Tokens
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.Tokens
instance Data.Aeson.Types.ToJSON.ToJSON Unison.Auth.Types.Scopes
instance Data.Aeson.Types.FromJSON.FromJSON Unison.Auth.Types.Scopes

module Unison.Auth.Discovery
discoveryURIForCodeserver :: CodeserverURI -> URI
fetchDiscoveryDoc :: MonadIO m => URI -> m (Either CredentialFailure DiscoveryDoc)

module Unison.Auth.CredentialFile

-- | Atomically update the credential storage file. Creates an empty file
--   automatically if one doesn't exist.
atomicallyModifyCredentialsFile :: MonadIO m => (Credentials -> Credentials) -> m Credentials

module Unison.Auth.CredentialManager

-- | Saves credentials to the active profile.
saveCredentials :: MonadUnliftIO m => CredentialManager -> CodeserverId -> CodeserverCredentials -> m ()

-- | A <a>CredentialManager</a> knows how to load, save, and cache
--   credentials. It's thread-safe and safe for use across multiple UCM
--   clients. Note: Currently the in-memory cache is _not_ updated if a
--   different UCM updates the credentials file, however this shouldn't
--   pose any problems, since auth will still be refreshed if we encounter
--   any auth failures on requests.
data CredentialManager
newCredentialManager :: MonadIO m => m CredentialManager
getCredentials :: MonadIO m => CredentialManager -> CodeserverId -> m (Either CredentialFailure CodeserverCredentials)

module Unison.Auth.Tokens

-- | Checks whether a JWT access token is expired.
isExpired :: MonadIO m => AccessToken -> m Bool

-- | Given a <a>CodeserverId</a>, provide a valid <a>AccessToken</a> for
--   the associated host. The TokenProvider may automatically refresh
--   access tokens if we have a refresh token.
type TokenProvider = CodeserverId -> IO (Either CredentialFailure AccessToken)

-- | Creates a <a>TokenProvider</a> using the given
--   <a>CredentialManager</a>
newTokenProvider :: CredentialManager -> TokenProvider

-- | Don't yet support automatically refreshing tokens.
--   
--   Specification:
--   <a>https://datatracker.ietf.org/doc/html/rfc6749#section-6</a>
performTokenRefresh :: MonadIO m => URI -> Tokens -> m (Either CredentialFailure Tokens)


-- | <tt>.unisonConfig</tt> file utilities
module Unison.Cli.UnisonConfigUtils
defaultMetadataKey :: Absolute -> Text
gitUrlKey :: Absolute -> Text
remoteMappingKey :: Absolute -> Text

module Unison.Codebase.Editor.AuthorInfo
data AuthorInfo v a
AuthorInfo :: (Id, Term v a, Type v a) -> AuthorInfo v a
[$sel:guid:AuthorInfo, $sel:author:AuthorInfo, $sel:copyrightHolder:AuthorInfo] :: AuthorInfo v a -> (Id, Term v a, Type v a)
createAuthorInfo :: forall m v a. MonadIO m => Var v => a -> Text -> m (AuthorInfo v a)

module Unison.Codebase.Editor.Input
data Input
ForkLocalBranchI :: Either ShortBranchHash Path' -> Path' -> Input
MergeLocalBranchI :: Path' -> Path' -> MergeMode -> Input
PreviewMergeLocalBranchI :: Path' -> Path' -> Input
DiffNamespaceI :: BranchId -> BranchId -> Input
PullRemoteBranchI :: Maybe ReadRemoteNamespace -> Path' -> SyncMode -> PullMode -> Verbosity -> Input
PushRemoteBranchI :: PushRemoteBranchInput -> Input
CreatePullRequestI :: ReadRemoteNamespace -> ReadRemoteNamespace -> Input
LoadPullRequestI :: ReadRemoteNamespace -> ReadRemoteNamespace -> Path' -> Input
ResetRootI :: Either ShortBranchHash Path' -> Input
CreateMessage :: Pretty ColorText -> Input
SwitchBranchI :: Maybe Path' -> Input
UpI :: Input
PopBranchI :: Input
NamesI :: IsGlobal -> HashQualified Name -> Input
AliasTermI :: HashOrHQSplit' -> Split' -> Input
AliasTypeI :: HashOrHQSplit' -> Split' -> Input
AliasManyI :: [HQSplit] -> Path' -> Input
MoveTermI :: HQSplit' -> Split' -> Input
MoveTypeI :: HQSplit' -> Split' -> Input
MoveBranchI :: Path' -> Path' -> Input
MovePatchI :: Split' -> Split' -> Input
CopyPatchI :: Split' -> Split' -> Input
DeleteI :: HQSplit' -> Input
DeleteTermI :: HQSplit' -> Input
DeleteTypeI :: HQSplit' -> Input
DeleteBranchI :: Insistence -> Maybe Split' -> Input
DeletePatchI :: Split' -> Input
ResolveTermNameI :: HQSplit' -> Input
ResolveTypeNameI :: HQSplit' -> Input
LoadI :: Maybe FilePath -> Input
AddI :: Set Name -> Input
PreviewAddI :: Set Name -> Input
UpdateI :: OptionalPatch -> Set Name -> Input
PreviewUpdateI :: Set Name -> Input
TodoI :: Maybe PatchPath -> Path' -> Input
PropagatePatchI :: PatchPath -> Path' -> Input
ListEditsI :: Maybe PatchPath -> Input
DeprecateTermI :: PatchPath -> HQSplit' -> Input
DeprecateTypeI :: PatchPath -> HQSplit' -> Input
ReplaceI :: HashQualified Name -> HashQualified Name -> Maybe PatchPath -> Input
RemoveTermReplacementI :: HashQualified Name -> Maybe PatchPath -> Input
RemoveTypeReplacementI :: HashQualified Name -> Maybe PatchPath -> Input
UndoI :: Input
HistoryI :: Maybe Int -> Maybe Int -> BranchId -> Input
ExecuteI :: String -> [String] -> Input
SaveExecuteResultI :: Name -> Input
IOTestI :: HashQualified Name -> Input
MakeStandaloneI :: String -> HashQualified Name -> Input
TestI :: TestInput -> Input
LinkI :: HashQualified Name -> [HQSplit'] -> Input
UnlinkI :: HashQualified Name -> [HQSplit'] -> Input
LinksI :: HQSplit' -> Maybe String -> Input
CreateAuthorI :: NameSegment -> Text -> Input
DisplayI :: OutputLocation -> [HashQualified Name] -> Input
DocsI :: [HQSplit'] -> Input
FindI :: Bool -> FindScope -> [String] -> Input
FindShallowI :: Path' -> Input
FindPatchI :: Input
ShowDefinitionI :: OutputLocation -> ShowDefinitionScope -> [HashQualified Name] -> Input
ShowDefinitionByPrefixI :: OutputLocation -> [HashQualified Name] -> Input
ShowReflogI :: Input
UpdateBuiltinsI :: Input
MergeBuiltinsI :: Input
MergeIOBuiltinsI :: Input
ListDependenciesI :: HashQualified Name -> Input
ListDependentsI :: HashQualified Name -> Input

-- | List all external dependencies of a given namespace, or the current
--   namespace if no path is provided.
NamespaceDependenciesI :: Maybe Path' -> Input
DebugTabCompletionI :: [String] -> Input
DebugNumberedArgsI :: Input
DebugTypecheckedUnisonFileI :: Input
DebugDumpNamespacesI :: Input
DebugDumpNamespaceSimpleI :: Input
DebugClearWatchI :: Input
DebugDoctorI :: Input
QuitI :: Input
ApiI :: Input
UiI :: Input
DocsToHtmlI :: Path' -> FilePath -> Input
GistI :: GistInput -> Input
AuthLoginI :: Input
VersionI :: Input

-- | <tt>"push.gist repo"</tt> pushes the contents of the current namespace
--   to <tt>repo</tt>.
data GistInput
GistInput :: WriteGitRepo -> GistInput
[$sel:repo:GistInput] :: GistInput -> WriteGitRepo
data PushRemoteBranchInput
PushRemoteBranchInput :: Path' -> Maybe WriteRemotePath -> PushBehavior -> SyncMode -> PushRemoteBranchInput

-- | The local path to push. If relative, it's resolved relative to the
--   current path (<tt>cd</tt>).
[$sel:localPath:PushRemoteBranchInput] :: PushRemoteBranchInput -> Path'

-- | The repo to push to. If missing, it is looked up in `.unisonConfig`.
[$sel:maybeRemoteRepo:PushRemoteBranchInput] :: PushRemoteBranchInput -> Maybe WriteRemotePath

-- | The push behavior (whether the remote branch is required to be empty
--   or non-empty).
[$sel:pushBehavior:PushRemoteBranchInput] :: PushRemoteBranchInput -> PushBehavior
[$sel:syncMode:PushRemoteBranchInput] :: PushRemoteBranchInput -> SyncMode
data TestInput
TestInput :: Bool -> Bool -> Bool -> TestInput

-- | Should we run tests in the <tt>lib</tt> namespace?
[$sel:includeLibNamespace:TestInput] :: TestInput -> Bool
[$sel:showFailures:TestInput] :: TestInput -> Bool
[$sel:showSuccesses:TestInput] :: TestInput -> Bool
data Event
UnisonFileChanged :: SourceName -> Source -> Event
IncomingRootBranch :: Set CausalHash -> Event
data OutputLocation
ConsoleLocation :: OutputLocation
LatestFileLocation :: OutputLocation
FileLocation :: FilePath -> OutputLocation
type PatchPath = Split'
type BranchId = Either ShortBranchHash Path'
type AbsBranchId = Either ShortBranchHash Absolute
parseBranchId :: String -> Either String BranchId
type HashOrHQSplit' = Either ShortHash HQSplit'

-- | Should we force the operation or not?
data Insistence
Force :: Insistence
Try :: Insistence
data PullMode
PullWithHistory :: PullMode
PullWithoutHistory :: PullMode
data OptionalPatch
NoPatch :: OptionalPatch
DefaultPatch :: OptionalPatch
UsePatch :: PatchPath -> OptionalPatch
data FindScope
FindLocal :: FindScope
FindLocalAndDeps :: FindScope
FindGlobal :: FindScope
data ShowDefinitionScope
ShowDefinitionLocal :: ShowDefinitionScope
ShowDefinitionGlobal :: ShowDefinitionScope
type IsGlobal = Bool
instance GHC.Show.Show Unison.Codebase.Editor.Input.OptionalPatch
instance GHC.Classes.Ord Unison.Codebase.Editor.Input.OptionalPatch
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.OptionalPatch
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.Insistence
instance GHC.Show.Show Unison.Codebase.Editor.Input.Insistence
instance GHC.Show.Show Unison.Codebase.Editor.Input.PullMode
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.PullMode
instance GHC.Show.Show Unison.Codebase.Editor.Input.GistInput
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.GistInput
instance GHC.Show.Show Unison.Codebase.Editor.Input.PushRemoteBranchInput
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.PushRemoteBranchInput
instance GHC.Show.Show Unison.Codebase.Editor.Input.TestInput
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.TestInput
instance GHC.Show.Show Unison.Codebase.Editor.Input.OutputLocation
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.OutputLocation
instance GHC.Show.Show Unison.Codebase.Editor.Input.FindScope
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.FindScope
instance GHC.Show.Show Unison.Codebase.Editor.Input.ShowDefinitionScope
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.ShowDefinitionScope
instance GHC.Show.Show Unison.Codebase.Editor.Input.Input
instance GHC.Classes.Eq Unison.Codebase.Editor.Input.Input

module Unison.Codebase.Editor.Output.BranchDiff
data MetadataDiff tm
MetadataDiff :: [tm] -> [tm] -> MetadataDiff tm
[$sel:addedMetadata:MetadataDiff] :: MetadataDiff tm -> [tm]
[$sel:removedMetadata:MetadataDiff] :: MetadataDiff tm -> [tm]
data BranchDiffOutput v a
BranchDiffOutput :: [UpdateTypeDisplay v a] -> [UpdateTermDisplay v a] -> [UpdateTypeDisplay v a] -> [UpdateTermDisplay v a] -> [UpdateTypeDisplay v a] -> [UpdateTermDisplay v a] -> Int -> [PatchDisplay] -> [AddedTypeDisplay v a] -> [AddedTermDisplay v a] -> [PatchDisplay] -> [RemovedTypeDisplay v a] -> [RemovedTermDisplay v a] -> [PatchDisplay] -> [RenameTypeDisplay v a] -> [RenameTermDisplay v a] -> BranchDiffOutput v a
[$sel:updatedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTypeDisplay v a]
[$sel:updatedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTermDisplay v a]
[$sel:newTypeConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTypeDisplay v a]
[$sel:newTermConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTermDisplay v a]
[$sel:resolvedTypeConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTypeDisplay v a]
[$sel:resolvedTermConflicts:BranchDiffOutput] :: BranchDiffOutput v a -> [UpdateTermDisplay v a]
[$sel:propagatedUpdates:BranchDiffOutput] :: BranchDiffOutput v a -> Int
[$sel:updatedPatches:BranchDiffOutput] :: BranchDiffOutput v a -> [PatchDisplay]
[$sel:addedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [AddedTypeDisplay v a]
[$sel:addedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [AddedTermDisplay v a]
[$sel:addedPatches:BranchDiffOutput] :: BranchDiffOutput v a -> [PatchDisplay]
[$sel:removedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [RemovedTypeDisplay v a]
[$sel:removedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [RemovedTermDisplay v a]
[$sel:removedPatches:BranchDiffOutput] :: BranchDiffOutput v a -> [PatchDisplay]
[$sel:renamedTypes:BranchDiffOutput] :: BranchDiffOutput v a -> [RenameTypeDisplay v a]
[$sel:renamedTerms:BranchDiffOutput] :: BranchDiffOutput v a -> [RenameTermDisplay v a]
isEmpty :: BranchDiffOutput v a -> Bool
type TermDisplay v a = (HashQualified Name, Referent, Maybe (Type v a), MetadataDiff (MetadataDisplay v a))
type TypeDisplay v a = (HashQualified Name, Reference, Maybe (DeclOrBuiltin v a), MetadataDiff (MetadataDisplay v a))
type AddedTermDisplay v a = ([(HashQualified Name, [MetadataDisplay v a])], Referent, Maybe (Type v a))
type AddedTypeDisplay v a = ([(HashQualified Name, [MetadataDisplay v a])], Reference, Maybe (DeclOrBuiltin v a))
type RemovedTermDisplay v a = ([HashQualified Name], Referent, Maybe (Type v a))
type RemovedTypeDisplay v a = ([HashQualified Name], Reference, Maybe (DeclOrBuiltin v a))
type SimpleTermDisplay v a = (HashQualified Name, Referent, Maybe (Type v a))
type SimpleTypeDisplay v a = (HashQualified Name, Reference, Maybe (DeclOrBuiltin v a))
type UpdateTermDisplay v a = (Maybe [SimpleTermDisplay v a], [TermDisplay v a])
type UpdateTypeDisplay v a = (Maybe [SimpleTypeDisplay v a], [TypeDisplay v a])
type MetadataDisplay v a = (HashQualified Name, Referent, Maybe (Type v a))
type RenameTermDisplay v a = (Referent, Maybe (Type v a), Set (HashQualified Name), Set (HashQualified Name))
type RenameTypeDisplay v a = (Reference, Maybe (DeclOrBuiltin v a), Set (HashQualified Name), Set (HashQualified Name))
type PatchDisplay = (Name, PatchDiff)
toOutput :: forall m v a. Monad m => (Referent -> m (Maybe (Type v a))) -> (Reference -> m (Maybe (DeclOrBuiltin v a))) -> Int -> Names -> Names -> PrettyPrintEnv -> BranchDiff -> m (BranchDiffOutput v a)
instance GHC.Show.Show tm => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)
instance Data.Traversable.Traversable Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff
instance Data.Foldable.Foldable Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff
instance GHC.Base.Functor Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff
instance GHC.Classes.Eq tm => GHC.Classes.Eq (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)
instance GHC.Classes.Ord tm => GHC.Classes.Ord (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)
instance (GHC.Show.Show a, GHC.Show.Show v) => GHC.Show.Show (Unison.Codebase.Editor.Output.BranchDiff.BranchDiffOutput v a)
instance GHC.Base.Semigroup (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)
instance GHC.Base.Monoid (Unison.Codebase.Editor.Output.BranchDiff.MetadataDiff tm)

module Unison.Codebase.Editor.Output.DumpNamespace
data DumpNamespace
DumpNamespace :: Map Referent (Set NameSegment, Set Reference) -> Map Reference (Set NameSegment, Set Reference) -> Map NameSegment EditHash -> Map NameSegment CausalHash -> Set CausalHash -> DumpNamespace
[$sel:terms:DumpNamespace] :: DumpNamespace -> Map Referent (Set NameSegment, Set Reference)
[$sel:types:DumpNamespace] :: DumpNamespace -> Map Reference (Set NameSegment, Set Reference)
[$sel:patches:DumpNamespace] :: DumpNamespace -> Map NameSegment EditHash
[$sel:children:DumpNamespace] :: DumpNamespace -> Map NameSegment CausalHash
[$sel:causalParents:DumpNamespace] :: DumpNamespace -> Set CausalHash
instance GHC.Show.Show Unison.Codebase.Editor.Output.DumpNamespace.DumpNamespace

module Unison.Codebase.Editor.Output.PushPull
data PushPull
Push :: PushPull
Pull :: PushPull
fold :: a -> a -> PushPull -> a
instance GHC.Show.Show Unison.Codebase.Editor.Output.PushPull.PushPull
instance GHC.Classes.Ord Unison.Codebase.Editor.Output.PushPull.PushPull
instance GHC.Classes.Eq Unison.Codebase.Editor.Output.PushPull.PushPull

module Unison.Codebase.Editor.SlurpComponent
data SlurpComponent v
SlurpComponent :: Set v -> Set v -> Set v -> SlurpComponent v
[$sel:types:SlurpComponent] :: SlurpComponent v -> Set v
[$sel:terms:SlurpComponent] :: SlurpComponent v -> Set v
[$sel:ctors:SlurpComponent] :: SlurpComponent v -> Set v
isEmpty :: SlurpComponent v -> Bool
empty :: Ord v => SlurpComponent v
difference :: Ord v => SlurpComponent v -> SlurpComponent v -> SlurpComponent v
intersection :: Ord v => SlurpComponent v -> SlurpComponent v -> SlurpComponent v
closeWithDependencies :: forall v a. Ord v => TypecheckedUnisonFile v a -> SlurpComponent v -> SlurpComponent v
fromTypes :: Ord v => Set v -> SlurpComponent v
fromTerms :: Ord v => Set v -> SlurpComponent v
fromCtors :: Ord v => Set v -> SlurpComponent v
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.SlurpComponent.SlurpComponent v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Codebase.Editor.SlurpComponent.SlurpComponent v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Codebase.Editor.SlurpComponent.SlurpComponent v)
instance GHC.Classes.Ord v => GHC.Base.Semigroup (Unison.Codebase.Editor.SlurpComponent.SlurpComponent v)
instance GHC.Classes.Ord v => GHC.Base.Monoid (Unison.Codebase.Editor.SlurpComponent.SlurpComponent v)

module Unison.Codebase.Editor.SlurpResult
data SlurpResult v
SlurpResult :: TypecheckedUnisonFile v Ann -> SlurpComponent v -> SlurpComponent v -> SlurpComponent v -> SlurpComponent v -> SlurpComponent v -> Set v -> Set v -> Map v Aliases -> Map v Aliases -> SlurpComponent v -> SlurpResult v
[$sel:originalFile:SlurpResult] :: SlurpResult v -> TypecheckedUnisonFile v Ann
[$sel:extraDefinitions:SlurpResult] :: SlurpResult v -> SlurpComponent v
[$sel:adds:SlurpResult] :: SlurpResult v -> SlurpComponent v
[$sel:duplicates:SlurpResult] :: SlurpResult v -> SlurpComponent v
[$sel:collisions:SlurpResult] :: SlurpResult v -> SlurpComponent v
[$sel:updates:SlurpResult] :: SlurpResult v -> SlurpComponent v
[$sel:termExistingConstructorCollisions:SlurpResult] :: SlurpResult v -> Set v
[$sel:constructorExistingTermCollisions:SlurpResult] :: SlurpResult v -> Set v
[$sel:termAlias:SlurpResult] :: SlurpResult v -> Map v Aliases
[$sel:typeAlias:SlurpResult] :: SlurpResult v -> Map v Aliases
[$sel:defsWithBlockedDependencies:SlurpResult] :: SlurpResult v -> SlurpComponent v
data Aliases
AddAliases :: Set Name -> Aliases
UpdateAliases :: Set Name -> Set Name -> Aliases
[$sel:oldRefNames:AddAliases] :: Aliases -> Set Name
[$sel:newRefNames:AddAliases] :: Aliases -> Set Name
isOk :: Ord v => SlurpResult v -> Bool
isAllDuplicates :: Ord v => SlurpResult v -> Bool
hasAddsOrUpdates :: Ord v => SlurpResult v -> Bool
filterUnisonFile :: Ord v => SlurpResult v -> TypecheckedUnisonFile v Ann -> TypecheckedUnisonFile v Ann
pretty :: forall v. Var v => IsPastTense -> PrettyPrintEnv -> SlurpResult v -> Pretty ColorText
data Status
Add :: Status
Update :: Status
Duplicate :: Status
Collision :: Status
TermExistingConstructorCollision :: Status
ConstructorExistingTermCollision :: Status
ExtraDefinition :: Status
BlockedDependency :: Status
prettyStatus :: Status -> Pretty ColorText
instance GHC.Classes.Ord Unison.Codebase.Editor.SlurpResult.Aliases
instance GHC.Classes.Eq Unison.Codebase.Editor.SlurpResult.Aliases
instance GHC.Show.Show Unison.Codebase.Editor.SlurpResult.Aliases
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.SlurpResult.SlurpResult v)
instance GHC.Show.Show Unison.Codebase.Editor.SlurpResult.Status
instance GHC.Classes.Eq Unison.Codebase.Editor.SlurpResult.Status
instance GHC.Classes.Ord Unison.Codebase.Editor.SlurpResult.Status

module Unison.Codebase.Editor.Slurp

-- | The operation which is being performed or checked.
data SlurpOp
AddOp :: SlurpOp
UpdateOp :: SlurpOp
CheckOp :: SlurpOp

-- | Analyze a file and determine the status of all of its definitions with
--   respect to a set of vars to analyze and an operation you wish to
--   perform.
slurpFile :: forall v. Var v => TypecheckedUnisonFile v Ann -> Set v -> SlurpOp -> Names -> SlurpResult v
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.SlurpOp
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.SlurpOp
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.Slurp.TaggedVar v)
instance GHC.Classes.Ord v => GHC.Classes.Ord (Unison.Codebase.Editor.Slurp.TaggedVar v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Unison.Codebase.Editor.Slurp.TaggedVar v)
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.DefnStatus
instance GHC.Classes.Ord Unison.Codebase.Editor.Slurp.DefnStatus
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.DefnStatus
instance GHC.Show.Show Unison.Codebase.Editor.Slurp.DepStatus
instance GHC.Classes.Ord Unison.Codebase.Editor.Slurp.DepStatus
instance GHC.Classes.Eq Unison.Codebase.Editor.Slurp.DepStatus
instance GHC.Classes.Ord v => GHC.Base.Semigroup (Unison.Codebase.Editor.Slurp.SlurpingSummary v)
instance GHC.Classes.Ord v => GHC.Base.Monoid (Unison.Codebase.Editor.Slurp.SlurpingSummary v)

module Unison.Codebase.Editor.TodoOutput
type Score = Int
data TodoOutput v a
TodoOutput :: Score -> ([(Reference, Maybe (Type v a))], [(Reference, DisplayObject () (Decl v a))]) -> ([(Score, Reference, Maybe (Type v a))], [(Score, Reference, DisplayObject () (Decl v a))]) -> Names -> Patch -> TodoOutput v a
[$sel:todoScore:TodoOutput] :: TodoOutput v a -> Score
[$sel:todoFrontier:TodoOutput] :: TodoOutput v a -> ([(Reference, Maybe (Type v a))], [(Reference, DisplayObject () (Decl v a))])
[$sel:todoFrontierDependents:TodoOutput] :: TodoOutput v a -> ([(Score, Reference, Maybe (Type v a))], [(Score, Reference, DisplayObject () (Decl v a))])
[$sel:nameConflicts:TodoOutput] :: TodoOutput v a -> Names
[$sel:editConflicts:TodoOutput] :: TodoOutput v a -> Patch
labeledDependencies :: Ord v => TodoOutput v a -> Set LabeledDependency
noConflicts :: TodoOutput v a -> Bool
noEdits :: TodoOutput v a -> Bool
instance (GHC.Show.Show v, GHC.Show.Show a) => GHC.Show.Show (Unison.Codebase.Editor.TodoOutput.TodoOutput v a)

module Unison.Codebase.Editor.UCMVersion
type UCMVersion = Text

module Unison.Codebase.Editor.UriParser
repoPath :: P ReadRemoteNamespace
writeGitRepo :: P WriteGitRepo

-- | A parser for the deprecated format of git URLs, which may still exist
--   in old GitURL unisonConfigs.
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "/srv/git/project.git:.namespace"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "/srv/git/project.git:branch:.namespace"
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "/srv/git/project.git", branch = Nothing}, path = namespace})
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "/srv/git/project.git", branch = Just "branch"}, path = namespace})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "file:///srv/git/project.git"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "file:///srv/git/project.git:branch"
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "file:///srv/git/project.git", branch = Nothing}, path = })
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "file:///srv/git/project.git", branch = Just "branch"}, path = })
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "https://example.com/gitproject.git"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "https://example.com/gitproject.git:base"
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "https://example.com/gitproject.git", branch = Nothing}, path = })
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "https://example.com/gitproject.git", branch = Just "base"}, path = })
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "ssh://user@server/project.git"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "ssh://user@server/project.git:branch"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "ssh://server/project.git"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "ssh://server/project.git:branch"
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "ssh://user@server/project.git", branch = Nothing}, path = })
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "ssh://user@server/project.git", branch = Just "branch"}, path = })
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "ssh://server/project.git", branch = Nothing}, path = })
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "ssh://server/project.git", branch = Just "branch"}, path = })
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "server:project"
--   
--   &gt;&gt;&gt; P.parseMaybe deprecatedWriteGitRemotePath "user@server:project.git:branch"
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "server:project", branch = Nothing}, path = })
--   Just (WriteGitRemotePath {repo = WriteGitRepo {url = "user@server:project.git", branch = Just "branch"}, path = })
--   </pre>
deprecatedWriteGitRemotePath :: P WriteGitRemotePath
writeRemotePath :: P WriteRemotePath
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.Scheme
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.Scheme
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.Scheme
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.User
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.User
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.User
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.HostInfo
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.HostInfo
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.HostInfo
instance GHC.Show.Show Unison.Codebase.Editor.UriParser.GitProtocol
instance GHC.Classes.Ord Unison.Codebase.Editor.UriParser.GitProtocol
instance GHC.Classes.Eq Unison.Codebase.Editor.UriParser.GitProtocol

module Unison.Codebase.Editor.VersionParser

-- | Parse git version strings into valid unison namespaces.
--   
--   <pre>
--   &gt;&gt;&gt; parseMaybe defaultBaseLib "release/M4"
--   
--   &gt;&gt;&gt; parseMaybe defaultBaseLib "release/M4b"
--   
--   &gt;&gt;&gt; parseMaybe defaultBaseLib "release/M4c.2"
--   Just (ReadShareRemoteNamespace {server = DefaultCodeserver, repo = "unison", path = public.base.releases.M4})
--   Just (ReadShareRemoteNamespace {server = DefaultCodeserver, repo = "unison", path = public.base.releases.M4b})
--   Just (ReadShareRemoteNamespace {server = DefaultCodeserver, repo = "unison", path = public.base.releases.M4c_2})
--   </pre>
defaultBaseLib :: Parsec Void Text ReadShareRemoteNamespace


-- | Command-line fuzzy selection of arbitrary values. Shells out to fzf
--   for the actual selection.
module Unison.CommandLine.FuzzySelect

-- | Allows prompting the user to interactively fuzzy-select a result from
--   a list of options, currently shells out to <tt>fzf</tt> under the
--   hood. If fzf is missing, or an error (other than ctrl-c) occurred,
--   returns Nothing.
fuzzySelect :: forall a. Options -> (a -> Text) -> [a] -> IO (Maybe [a])

-- | Fuzzy Selection options
data Options
Options :: Bool -> Options
[$sel:allowMultiSelect:Options] :: Options -> Bool

-- | Default <a>Options</a>
defaultOptions :: Options


-- | Provides Globbing for selecting types, terms and namespaces using
--   wildcards.
module Unison.CommandLine.Globbing

-- | Expand a single glob pattern into all matching targets of the
--   specified types.
expandGlobs :: forall m. Set TargetType -> Branch0 m -> Absolute -> String -> Maybe [String]
containsGlob :: String -> Bool

-- | Possible targets which a glob may select.
data TargetType
Type :: TargetType
Term :: TargetType
Namespace :: TargetType
instance GHC.Show.Show Unison.CommandLine.Globbing.TargetType
instance GHC.Classes.Ord Unison.CommandLine.Globbing.TargetType
instance GHC.Classes.Eq Unison.CommandLine.Globbing.TargetType
instance GHC.Show.Show Unison.CommandLine.Globbing.GlobArg

module Unison.CommandLine.Welcome
data Welcome
Welcome :: Onboarding -> DownloadBase -> FilePath -> Text -> Welcome
[$sel:onboarding:Welcome] :: Welcome -> Onboarding
[$sel:downloadBase:Welcome] :: Welcome -> DownloadBase
[$sel:watchDir:Welcome] :: Welcome -> FilePath
[$sel:unisonVersion:Welcome] :: Welcome -> Text
data DownloadBase
DownloadBase :: ReadShareRemoteNamespace -> DownloadBase
DontDownloadBase :: DownloadBase
data CodebaseInitStatus
NewlyCreatedCodebase :: CodebaseInitStatus
PreviouslyCreatedCodebase :: CodebaseInitStatus
data Onboarding
Init :: CodebaseInitStatus -> Onboarding
DownloadingBase :: ReadShareRemoteNamespace -> Onboarding
Author :: Onboarding
Finished :: Onboarding
PreviouslyOnboarded :: Onboarding
welcome :: CodebaseInitStatus -> DownloadBase -> FilePath -> Text -> Welcome
pullBase :: ReadShareRemoteNamespace -> Either Event Input
run :: Codebase IO v a -> Welcome -> IO [Either Event Input]
toInput :: Pretty ColorText -> Either Event Input
determineFirstStep :: DownloadBase -> Codebase IO v a -> IO Onboarding
asciiartUnison :: Pretty ColorText
downloading :: Path -> Pretty ColorText
header :: Text -> Pretty ColorText
authorSuggestion :: Pretty ColorText
getStarted :: FilePath -> IO (Pretty ColorText)
instance GHC.Classes.Eq Unison.CommandLine.Welcome.DownloadBase
instance GHC.Show.Show Unison.CommandLine.Welcome.DownloadBase
instance GHC.Classes.Eq Unison.CommandLine.Welcome.CodebaseInitStatus
instance GHC.Show.Show Unison.CommandLine.Welcome.CodebaseInitStatus
instance GHC.Classes.Eq Unison.CommandLine.Welcome.Onboarding
instance GHC.Show.Show Unison.CommandLine.Welcome.Onboarding


-- | Instances for LSP types which are strangely missing.
module Unison.LSP.Orphans
instance GHC.Classes.Ord Language.LSP.Types.TextDocument.TextDocumentIdentifier
instance Language.LSP.Types.Lens.HasTextDocument Language.LSP.Types.TextDocument.TextDocumentIdentifier Language.LSP.Types.TextDocument.TextDocumentIdentifier
instance Language.LSP.Types.Lens.HasTextDocument Language.LSP.Types.TextDocument.VersionedTextDocumentIdentifier Language.LSP.Types.TextDocument.VersionedTextDocumentIdentifier
instance Language.LSP.Types.Lens.HasUri Language.LSP.Types.Uri.NormalizedUri Language.LSP.Types.Uri.Uri

module Unison.LSP.Conversions
rangeToInterval :: Range -> Interval Position
uToLspPos :: Pos -> Position
uToLspRange :: Range -> Range
annToRange :: Ann -> Maybe Range

module Unison.LSP.Types

-- | A custom LSP monad wrapper so we can provide our own environment.
newtype Lsp a
Lsp :: ReaderT Env (LspM Config) a -> Lsp a
[$sel:runLspM:Lsp] :: Lsp a -> ReaderT Env (LspM Config) a

-- | Log an info message to the client's LSP log.
logInfo :: Text -> Lsp ()

-- | Log an error message to the client's LSP log, this will be shown to
--   the user in most LSP implementations.
logError :: Text -> Lsp ()

-- | Environment for the Lsp monad.
data Env
Env :: LanguageContextEnv Config -> Codebase IO Symbol Ann -> IO NamesWithHistory -> IO PrettyPrintEnvDecl -> IO Absolute -> MVar VFS -> Runtime Symbol -> TVar (Map Uri FileAnalysis) -> TVar (Set Uri) -> TVar (Map SomeLspId (IO ())) -> Scope -> Env
[$sel:lspContext:Env] :: Env -> LanguageContextEnv Config
[$sel:codebase:Env] :: Env -> Codebase IO Symbol Ann
[$sel:parseNamesCache:Env] :: Env -> IO NamesWithHistory
[$sel:ppeCache:Env] :: Env -> IO PrettyPrintEnvDecl
[$sel:currentPathCache:Env] :: Env -> IO Absolute
[$sel:vfsVar:Env] :: Env -> MVar VFS
[$sel:runtime:Env] :: Env -> Runtime Symbol
[$sel:checkedFilesVar:Env] :: Env -> TVar (Map Uri FileAnalysis)
[$sel:dirtyFilesVar:Env] :: Env -> TVar (Set Uri)
[$sel:cancellationMapVar:Env] :: Env -> TVar (Map SomeLspId (IO ()))
[$sel:scope:Env] :: Env -> Scope

-- | A monotonically increasing file version tracked by the lsp client.
type FileVersion = Int32
type LexedSource = (Text, [Token Lexeme])
data FileAnalysis
FileAnalysis :: Uri -> FileVersion -> LexedSource -> Maybe (UnisonFile Symbol Ann) -> Maybe (TypecheckedUnisonFile Symbol Ann) -> Seq (Note Symbol Ann) -> IntervalMap Position [Diagnostic] -> IntervalMap Position [CodeAction] -> FileAnalysis
[$sel:fileUri:FileAnalysis] :: FileAnalysis -> Uri
[$sel:fileVersion:FileAnalysis] :: FileAnalysis -> FileVersion
[$sel:lexedSource:FileAnalysis] :: FileAnalysis -> LexedSource
[$sel:parsedFile:FileAnalysis] :: FileAnalysis -> Maybe (UnisonFile Symbol Ann)
[$sel:typecheckedFile:FileAnalysis] :: FileAnalysis -> Maybe (TypecheckedUnisonFile Symbol Ann)
[$sel:notes:FileAnalysis] :: FileAnalysis -> Seq (Note Symbol Ann)
[$sel:diagnostics:FileAnalysis] :: FileAnalysis -> IntervalMap Position [Diagnostic]
[$sel:codeActions:FileAnalysis] :: FileAnalysis -> IntervalMap Position [CodeAction]
getCurrentPath :: Lsp Absolute
globalPPE :: Lsp PrettyPrintEnvDecl
getParseNames :: Lsp NamesWithHistory
data Config
Config :: Config

-- | Lift a backend computation into the Lsp monad.
lspBackend :: Backend IO a -> Lsp (Either BackendError a)
sendNotification :: forall (m :: Method 'FromServer 'Notification). Message m ~ NotificationMessage m => NotificationMessage m -> Lsp ()
data RangedCodeAction
RangedCodeAction :: [Range] -> CodeAction -> RangedCodeAction
[$sel:_codeActionRanges:RangedCodeAction] :: RangedCodeAction -> [Range]
[$sel:_codeAction:RangedCodeAction] :: RangedCodeAction -> CodeAction
rangedCodeAction :: Text -> [Diagnostic] -> [Range] -> RangedCodeAction

-- | Provided ranges must not intersect.
includeEdits :: Uri -> Text -> [Range] -> RangedCodeAction -> RangedCodeAction
instance GHC.Show.Show Unison.LSP.Types.FileAnalysis
instance Language.LSP.Server.Core.MonadLsp Unison.LSP.Types.Config Unison.LSP.Types.Lsp
instance Control.Monad.Reader.Class.MonadReader Unison.LSP.Types.Env Unison.LSP.Types.Lsp
instance Control.Monad.IO.Unlift.MonadUnliftIO Unison.LSP.Types.Lsp
instance Control.Monad.IO.Class.MonadIO Unison.LSP.Types.Lsp
instance GHC.Base.Monad Unison.LSP.Types.Lsp
instance GHC.Base.Applicative Unison.LSP.Types.Lsp
instance GHC.Base.Functor Unison.LSP.Types.Lsp
instance GHC.Show.Show Unison.LSP.Types.RangedCodeAction
instance GHC.Classes.Eq Unison.LSP.Types.RangedCodeAction
instance Language.LSP.Types.Lens.HasCodeAction Unison.LSP.Types.RangedCodeAction Language.LSP.Types.CodeAction.CodeAction

module Unison.LSP.NotificationHandlers
initializedHandler :: NotificationMessage 'Initialized -> Lsp ()
withDebugging :: Show m => (m -> Lsp ()) -> m -> Lsp ()

module Unison.LSP.HandlerUtils

-- | Cancels an in-flight request
cancelRequest :: SomeLspId -> Lsp ()
withDebugging :: (Show (RequestMessage message), Show (ResponseResult message)) => (RequestMessage message -> (Either ResponseError (ResponseResult message) -> Lsp ()) -> Lsp ()) -> RequestMessage message -> (Either ResponseError (ResponseResult message) -> Lsp ()) -> Lsp ()

-- | Handler middleware to add the ability for the client to cancel
--   long-running in-flight requests.
withCancellation :: forall message. Maybe Int -> (RequestMessage message -> (Either ResponseError (ResponseResult message) -> Lsp ()) -> Lsp ()) -> RequestMessage message -> (Either ResponseError (ResponseResult message) -> Lsp ()) -> Lsp ()

module Unison.LSP.Diagnostics
annToRange :: Ann -> Maybe Range
uToLspPos :: Pos -> Position
uToLspRange :: Range -> Range
reportDiagnostics :: Foldable f => Uri -> Maybe FileVersion -> f Diagnostic -> Lsp ()
mkDiagnostic :: Uri -> Range -> DiagnosticSeverity -> Text -> [(Text, Range)] -> Diagnostic

module Unison.LSP.CancelRequest

-- | Allows a client to cancel work from a previous request.
cancelRequestHandler :: NotificationMessage 'CancelRequest -> Lsp ()

module Unison.LSP.VFS

-- | Some VFS combinators require Monad State, this provides it in a
--   transactionally safe manner so we're sure we don't edit the same file
--   in two different actions at the same time.
usingVFS :: forall a. StateT VFS Lsp a -> Lsp a
getVirtualFile :: HasUri doc Uri => doc -> Lsp (Maybe VirtualFile)
getFileContents :: HasUri doc Uri => doc -> Lsp (Maybe (FileVersion, Text))
vfsLogger :: LogAction (StateT VFS Lsp) (WithSeverity VfsLog)

-- | Mark some files as needing to be checked.
markFilesDirty :: (Foldable f, HasUri doc Uri) => f doc -> Lsp ()

-- | Mark all files for re-checking.
--   
--   We may want to do this when our names or perspective change.
markAllFilesDirty :: Lsp ()

-- | Returns the name or symbol which the provided position is contained
--   in.
identifierAtPosition :: (HasPosition p Position, HasTextDocument p TextDocumentIdentifier) => p -> Lsp (Maybe Text)

-- | Returns the prefix and suffix of the symbol which the provided
--   position is contained in.
identifierSplitAtPosition :: (HasPosition p Position, HasTextDocument p docId, HasUri docId Uri) => p -> Lsp (Maybe (Text, Text))

-- | Returns the prefix of the symbol at the provided location, and the
--   range that prefix spans.
completionPrefix :: (HasPosition p Position, HasTextDocument p docId, HasUri docId Uri) => p -> Lsp (Maybe (Range, Text))
lspOpenFile :: NotificationMessage 'TextDocumentDidOpen -> Lsp ()
lspCloseFile :: NotificationMessage 'TextDocumentDidClose -> Lsp ()
lspChangeFile :: NotificationMessage 'TextDocumentDidChange -> Lsp ()

module Unison.LSP.UCMWorker

-- | Watches for state changes in UCM and updates cached LSP state
--   accordingly
ucmWorker :: TVar PrettyPrintEnvDecl -> TVar NamesWithHistory -> STM (Branch IO) -> STM Absolute -> Lsp ()

module Unison.LSP.Hover

-- | Rudimentary hover handler
--   
--   TODO: Add docs, use FileAnalysis to select hover target.
hoverHandler :: RequestMessage 'TextDocumentHover -> (Either ResponseError (ResponseResult 'TextDocumentHover) -> Lsp ()) -> Lsp ()

module Unison.LSP.Completion

-- | Rudimentary auto-completion handler
--   
--   TODO: * Rewrite this to use an index rather than fuzzy searching ALL
--   names * Respect ucm's current path * Provide namespaces as
--   auto-complete targets * Auto-complete minimally suffixed names *
--   Include docs in completion details?
completionHandler :: RequestMessage 'TextDocumentCompletion -> (Either ResponseError (ResponseResult 'TextDocumentCompletion) -> Lsp ()) -> Lsp ()
snippetCompletions :: Text -> Range -> [CompletionItem]
mkCompletionItem :: Text -> CompletionItem

module Unison.Share.Codeserver

-- | This is the URI where the share API is based.
defaultCodeserver :: CodeserverURI
resolveCodeserver :: ShareCodeserver -> CodeserverURI


-- | Types used by the UCM client during sync.
module Unison.Share.Sync.Types

-- | Error used by the client when pushing code to Unison Share.
data CheckAndSetPushError
CheckAndSetPushErrorHashMismatch :: HashMismatch -> CheckAndSetPushError
CheckAndSetPushErrorNoWritePermission :: Path -> CheckAndSetPushError
CheckAndSetPushErrorServerMissingDependencies :: NESet Hash32 -> CheckAndSetPushError

-- | An error occurred while fast-forward pushing code to Unison Share.
data FastForwardPushError
FastForwardPushErrorNoHistory :: Path -> FastForwardPushError
FastForwardPushErrorNoReadPermission :: Path -> FastForwardPushError
FastForwardPushErrorNotFastForward :: Path -> FastForwardPushError
FastForwardPushErrorNoWritePermission :: Path -> FastForwardPushError
FastForwardPushErrorServerMissingDependencies :: NESet Hash32 -> FastForwardPushError
FastForwardPushInvalidParentage :: Hash32 -> Hash32 -> FastForwardPushError

-- | An error occurred while pulling code from Unison Share.
data PullError

-- | An error occurred while resolving a repo+path to a causal hash.
PullErrorGetCausalHashByPath :: GetCausalHashByPathError -> PullError
PullErrorNoHistoryAtPath :: Path -> PullError

-- | An error occurred when getting causal hash by path.
data GetCausalHashByPathError

-- | The user does not have permission to read this path.
GetCausalHashByPathErrorNoReadPermission :: Path -> GetCausalHashByPathError

-- | Generic Codeserver transport errors
data CodeserverTransportError
DecodeFailure :: Text -> Response -> CodeserverTransportError
PermissionDenied :: Text -> CodeserverTransportError
RateLimitExceeded :: CodeserverTransportError
Timeout :: CodeserverTransportError
Unauthenticated :: BaseUrl -> CodeserverTransportError
UnexpectedResponse :: Response -> CodeserverTransportError
UnreachableCodeserver :: BaseUrl -> CodeserverTransportError
data SyncError e
TransportError :: CodeserverTransportError -> SyncError e
SyncError :: e -> SyncError e
instance GHC.Show.Show Unison.Share.Sync.Types.CheckAndSetPushError
instance GHC.Show.Show Unison.Share.Sync.Types.FastForwardPushError
instance GHC.Show.Show Unison.Share.Sync.Types.GetCausalHashByPathError
instance GHC.Show.Show Unison.Share.Sync.Types.PullError
instance GHC.Exception.Type.Exception Unison.Share.Sync.Types.CodeserverTransportError
instance GHC.Show.Show Unison.Share.Sync.Types.CodeserverTransportError

module Unison.Util.HTTP
addRequestMiddleware :: (Request -> IO Request) -> ManagerSettings -> ManagerSettings
setUserAgent :: Text -> ManagerSettings -> ManagerSettings
ucmUserAgent :: UCMVersion -> Text

module Unison.Auth.HTTPClient

-- | Returns a new http manager which applies the appropriate Authorization
--   header to any hosts our UCM is authenticated with.
newAuthenticatedHTTPClient :: MonadIO m => TokenProvider -> UCMVersion -> m AuthenticatedHttpClient

-- | Newtype to delineate HTTP Managers with access-token logic.
newtype AuthenticatedHttpClient
AuthenticatedHttpClient :: Manager -> AuthenticatedHttpClient

module Unison.Share.Sync

-- | Get the causal hash of a path hosted on Unison Share.
getCausalHashByPath :: AuthenticatedHttpClient -> BaseUrl -> Path -> IO (Either GetCausalHashByPathError (Maybe HashJWT))

-- | An error occurred when getting causal hash by path.
data GetCausalHashByPathError

-- | The user does not have permission to read this path.
GetCausalHashByPathErrorNoReadPermission :: Path -> GetCausalHashByPathError

-- | Perform a check-and-set push (initially of just a causal hash, but
--   ultimately all of its dependencies that the server is missing, too) to
--   Unison Share.
--   
--   This flavor of push takes the expected state of the server, and the
--   desired state we want to set; if our expectation is off, we won't
--   proceed with the push.
checkAndSetPush :: AuthenticatedHttpClient -> BaseUrl -> (forall a. (Connection -> IO a) -> IO a) -> Path -> Maybe Hash32 -> CausalHash -> (Int -> IO ()) -> IO (Either (SyncError CheckAndSetPushError) ())

-- | Error used by the client when pushing code to Unison Share.
data CheckAndSetPushError
CheckAndSetPushErrorHashMismatch :: HashMismatch -> CheckAndSetPushError
CheckAndSetPushErrorNoWritePermission :: Path -> CheckAndSetPushError
CheckAndSetPushErrorServerMissingDependencies :: NESet Hash32 -> CheckAndSetPushError

-- | Perform a fast-forward push (initially of just a causal hash, but
--   ultimately all of its dependencies that the server is missing, too) to
--   Unison Share.
--   
--   This flavor of push provides the server with a chain of causal hashes
--   leading from its current state to our desired state.
fastForwardPush :: AuthenticatedHttpClient -> BaseUrl -> (forall a. (Connection -> IO a) -> IO a) -> Path -> CausalHash -> (Int -> IO ()) -> IO (Either (SyncError FastForwardPushError) ())

-- | An error occurred while fast-forward pushing code to Unison Share.
data FastForwardPushError
FastForwardPushErrorNoHistory :: Path -> FastForwardPushError
FastForwardPushErrorNoReadPermission :: Path -> FastForwardPushError
FastForwardPushErrorNotFastForward :: Path -> FastForwardPushError
FastForwardPushErrorNoWritePermission :: Path -> FastForwardPushError
FastForwardPushErrorServerMissingDependencies :: NESet Hash32 -> FastForwardPushError
FastForwardPushInvalidParentage :: Hash32 -> Hash32 -> FastForwardPushError
pull :: AuthenticatedHttpClient -> BaseUrl -> (forall a. (Connection -> IO a) -> IO a) -> Path -> (Int -> IO ()) -> IO (Either (SyncError PullError) CausalHash)

-- | An error occurred while pulling code from Unison Share.
data PullError

-- | An error occurred while resolving a repo+path to a causal hash.
PullErrorGetCausalHashByPath :: GetCausalHashByPathError -> PullError
PullErrorNoHistoryAtPath :: Path -> PullError

module Unison.CommandLine.InputPattern
data InputPattern
InputPattern :: String -> [String] -> Visibility -> [(IsOptional, ArgumentType)] -> Pretty ColorText -> ([String] -> Either (Pretty ColorText) Input) -> InputPattern
[$sel:patternName:InputPattern] :: InputPattern -> String
[$sel:aliases:InputPattern] :: InputPattern -> [String]
[$sel:visibility:InputPattern] :: InputPattern -> Visibility
[$sel:argTypes:InputPattern] :: InputPattern -> [(IsOptional, ArgumentType)]
[$sel:help:InputPattern] :: InputPattern -> Pretty ColorText
[$sel:parse:InputPattern] :: InputPattern -> [String] -> Either (Pretty ColorText) Input
data ArgumentType
ArgumentType :: String -> (forall m v a. MonadIO m => String -> Codebase m v a -> AuthenticatedHttpClient -> Absolute -> m [Completion]) -> Set TargetType -> ArgumentType
[$sel:typeName:ArgumentType] :: ArgumentType -> String

-- | Generate completion suggestions for this argument type
[$sel:suggestions:ArgumentType] :: ArgumentType -> forall m v a. MonadIO m => String -> Codebase m v a -> AuthenticatedHttpClient -> Absolute -> m [Completion]

-- | Select which targets glob patterns may expand into for this argument.
--   An empty set disables globbing.
[$sel:globTargets:ArgumentType] :: ArgumentType -> Set TargetType
argType :: InputPattern -> Int -> Maybe ArgumentType
data IsOptional
Required :: IsOptional
Optional :: IsOptional
ZeroPlus :: IsOptional
OnePlus :: IsOptional
data Visibility
Hidden :: Visibility
Visible :: Visibility
minArgs :: InputPattern -> Int
maxArgs :: InputPattern -> Maybe Int
instance GHC.Classes.Eq Unison.CommandLine.InputPattern.IsOptional
instance GHC.Show.Show Unison.CommandLine.InputPattern.IsOptional
instance GHC.Classes.Ord Unison.CommandLine.InputPattern.Visibility
instance GHC.Classes.Eq Unison.CommandLine.InputPattern.Visibility
instance GHC.Show.Show Unison.CommandLine.InputPattern.Visibility
instance GHC.Show.Show Unison.CommandLine.InputPattern.ArgumentType

module Unison.CommandLine
allow :: FilePath -> Bool
backtick :: IsString s => Pretty s -> Pretty s
aside :: (ListLike s Char, IsString s) => Pretty s -> Pretty s -> Pretty s
bigproblem :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
note :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
nothingTodo :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
plural :: Foldable f => f a -> b -> b -> b
plural' :: Integral a => a -> b -> b -> b
problem :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
tip :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
warn :: (ListLike s Char, IsString s) => Pretty s -> Pretty s
warnNote :: String -> String
parseInput :: IO (Branch0 m) -> Absolute -> [String] -> Map String InputPattern -> [String] -> IO (Either (Pretty ColorText) Input)
prompt :: String
watchConfig :: FilePath -> IO (Config, IO ())
watchFileSystem :: TQueue Event -> FilePath -> IO (IO ())

module Unison.Codebase.Editor.Output
data Output
Success :: Output
NoUnisonFile :: Output
PrintMessage :: Pretty ColorText -> Output
InvalidSourceName :: String -> Output
SourceLoadFailed :: String -> Output
NoMainFunction :: String -> PrettyPrintEnv -> [Type Symbol Ann] -> Output
BadMainFunction :: String -> Type Symbol Ann -> PrettyPrintEnv -> [Type Symbol Ann] -> Output
BranchEmpty :: Either ShortBranchHash Path' -> Output
BranchNotEmpty :: Path' -> Output
LoadPullRequest :: ReadRemoteNamespace -> ReadRemoteNamespace -> Path' -> Path' -> Path' -> Path' -> Output
CreatedNewBranch :: Absolute -> Output
BranchAlreadyExists :: Path' -> Output
FindNoLocalMatches :: Output
PatchAlreadyExists :: Split' -> Output
NoExactTypeMatches :: Output
TypeAlreadyExists :: Split' -> Set Reference -> Output
TypeParseError :: String -> Err Symbol -> Output
ParseResolutionFailures :: String -> [ResolutionFailure Symbol Ann] -> Output
TypeHasFreeVars :: Type Symbol Ann -> Output
TermAlreadyExists :: Split' -> Set Referent -> Output
LabeledReferenceAmbiguous :: Int -> HashQualified Name -> Set LabeledDependency -> Output
LabeledReferenceNotFound :: HashQualified Name -> Output
DeleteNameAmbiguous :: Int -> HQSplit' -> Set Referent -> Set Reference -> Output
TermAmbiguous :: HashQualified Name -> Set Referent -> Output
HashAmbiguous :: ShortHash -> Set Referent -> Output
BranchHashAmbiguous :: ShortBranchHash -> Set ShortBranchHash -> Output
BadNamespace :: String -> String -> Output
BranchNotFound :: Path' -> Output
EmptyPush :: Path' -> Output
NameNotFound :: HQSplit' -> Output
PatchNotFound :: Split' -> Output
TypeNotFound :: HQSplit' -> Output
TermNotFound :: HQSplit' -> Output
TypeNotFound' :: ShortHash -> Output
TermNotFound' :: ShortHash -> Output
TypeTermMismatch :: HashQualified Name -> HashQualified Name -> Output
NoLastRunResult :: Output
SaveTermNameConflict :: Name -> Output
SearchTermsNotFound :: [HashQualified Name] -> Output
SearchTermsNotFoundDetailed :: Bool -> [HashQualified Name] -> [HashQualified Name] -> Output
DeleteBranchConfirmation :: [(Path', (Names, [SearchResult' Symbol Ann]))] -> Output
DeleteEverythingConfirmation :: Output
MoveRootBranchConfirmation :: Output
MovedOverExistingBranch :: Path' -> Output
DeletedEverything :: Output
ListNames :: IsGlobal -> Int -> [(Reference, Set (HashQualified Name))] -> [(Referent, Set (HashQualified Name))] -> Output
ListOfDefinitions :: FindScope -> PrettyPrintEnv -> ListDetailed -> [SearchResult' Symbol Ann] -> Output
ListOfLinks :: PrettyPrintEnv -> [(HashQualified Name, Reference, Maybe (Type Symbol Ann))] -> Output
ListShallow :: IO PrettyPrintEnv -> [ShallowListEntry Symbol Ann] -> Output
ListOfPatches :: Set Name -> Output
SlurpOutput :: Input -> PrettyPrintEnv -> SlurpResult Symbol -> Output
ParseErrors :: Text -> [Err Symbol] -> Output
TypeErrors :: Absolute -> Text -> PrettyPrintEnv -> [ErrorNote Symbol Ann] -> Output
CompilerBugs :: Text -> PrettyPrintEnv -> [CompilerBug Symbol Ann] -> Output
DisplayConflicts :: Relation Name Referent -> Relation Name Reference -> Output
EvaluationFailure :: Error -> Output
Evaluated :: SourceFileContents -> PrettyPrintEnv -> [(Symbol, Term Symbol ())] -> Map Symbol (Ann, WatchKind, Term Symbol (), IsCacheHit) -> Output
RunResult :: PrettyPrintEnv -> Term Symbol () -> Output
Typechecked :: SourceName -> PrettyPrintEnv -> SlurpResult Symbol -> TypecheckedUnisonFile Symbol Ann -> Output
DisplayRendered :: Maybe FilePath -> Pretty ColorText -> Output
DisplayDefinitions :: Maybe FilePath -> PrettyPrintEnvDecl -> Map Reference (DisplayObject () (Decl Symbol Ann)) -> Map Reference (DisplayObject (Type Symbol Ann) (Term Symbol Ann)) -> Output
TestIncrementalOutputStart :: PrettyPrintEnv -> (Int, Int) -> Reference -> Term Symbol Ann -> Output
TestIncrementalOutputEnd :: PrettyPrintEnv -> (Int, Int) -> Reference -> Term Symbol Ann -> Output
TestResults :: TestReportStats -> PrettyPrintEnv -> ShowSuccesses -> ShowFailures -> [(Reference, Text)] -> [(Reference, Text)] -> Output
CantUndo :: UndoFailureReason -> Output
BustedBuiltins :: Set Reference -> Set Reference -> Output
GitError :: GitError -> Output
ShareError :: ShareError -> Output
ViewOnShare :: WriteShareRemotePath -> Output
ConfiguredMetadataParseError :: Path' -> String -> Pretty ColorText -> Output
NoConfiguredRemoteMapping :: PushPull -> Absolute -> Output
ConfiguredRemoteMappingParseError :: PushPull -> Absolute -> Text -> String -> Output
MetadataMissingType :: PrettyPrintEnv -> Referent -> Output
TermMissingType :: Reference -> Output
MetadataAmbiguous :: HashQualified Name -> PrettyPrintEnv -> [Referent] -> Output
NothingToPatch :: PatchPath -> Path' -> Output
PatchNeedsToBeConflictFree :: Output
PatchInvolvesExternalDependents :: PrettyPrintEnv -> Set Reference -> Output
WarnIncomingRootBranch :: ShortBranchHash -> Set ShortBranchHash -> Output
StartOfCurrentPathHistory :: Output
ShowReflog :: [(Maybe UTCTime, ShortBranchHash, Text)] -> Output
PullAlreadyUpToDate :: ReadRemoteNamespace -> Path' -> Output
PullSuccessful :: ReadRemoteNamespace -> Path' -> Output

-- | Indicates a trivial merge where the destination was empty and was just
--   replaced.
MergeOverEmpty :: Path' -> Output
MergeAlreadyUpToDate :: Path' -> Path' -> Output
PreviewMergeAlreadyUpToDate :: Path' -> Path' -> Output

-- | No conflicts or edits remain for the current patch.
NoConflictsOrEdits :: Output
NotImplemented :: Output
NoBranchWithHash :: ShortBranchHash -> Output
ListDependencies :: Int -> LabeledDependency -> [(Name, Reference)] -> Set Reference -> Output

-- | List dependents of a type or term.
ListDependents :: Int -> LabeledDependency -> [(Reference, Maybe Name)] -> Output

-- | List all direct dependencies which don't have any names in the current
--   branch
ListNamespaceDependencies :: PrettyPrintEnv -> Absolute -> Map LabeledDependency (Set Name) -> Output
DumpNumberedArgs :: NumberedArgs -> Output
DumpBitBooster :: CausalHash -> Map CausalHash [CausalHash] -> Output
DumpUnisonFileHashes :: Int -> [(Name, Id)] -> [(Name, Id)] -> [(Name, Id)] -> Output
BadName :: String -> Output
DefaultMetadataNotification :: Output
CouldntLoadBranch :: CausalHash -> Output
HelpMessage :: InputPattern -> Output
NamespaceEmpty :: NonEmpty AbsBranchId -> Output
NoOp :: Output
RefusedToPush :: PushBehavior -> WriteRemotePath -> Output

-- | <tt>GistCreated repo</tt> means a causal was just published to
--   <tt>repo</tt>.
GistCreated :: ReadRemoteNamespace -> Output

-- | Directs the user to URI to begin an authorization flow.
InitiateAuthFlow :: URI -> Output
UnknownCodeServer :: Text -> Output
CredentialFailureMsg :: CredentialFailure -> Output
PrintVersion :: Text -> Output
IntegrityCheck :: IntegrityResult -> Output
DisplayDebugCompletions :: [Completion] -> Output
data NumberedOutput
ShowDiffNamespace :: AbsBranchId -> AbsBranchId -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterUndo :: PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterDeleteDefinitions :: PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterDeleteBranch :: Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterModifyBranch :: Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterMerge :: Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterMergePropagate :: Path' -> Absolute -> Path' -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterMergePreview :: Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterPull :: Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterCreatePR :: ReadRemoteNamespace -> ReadRemoteNamespace -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput
ShowDiffAfterCreateAuthor :: NameSegment -> Path' -> Absolute -> PrettyPrintEnv -> BranchDiffOutput Symbol Ann -> NumberedOutput

-- | Invariant: there's at least one conflict or edit in the TodoOutput.
TodoOutput :: PrettyPrintEnvDecl -> TodoOutput Symbol Ann -> NumberedOutput

-- | CantDeleteDefinitions ppe couldntDelete becauseTheseStillReferenceThem
CantDeleteDefinitions :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedOutput

-- | CantDeleteNamespace ppe couldntDelete becauseTheseStillReferenceThem
CantDeleteNamespace :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedOutput

-- | DeletedDespiteDependents ppe deletedThings
--   thingsWhichNowHaveUnnamedReferences
DeletedDespiteDependents :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedOutput

-- | size limit, history , how the history ends
History :: Maybe Int -> HashLength -> [(CausalHash, Diff)] -> HistoryTail -> NumberedOutput
ListEdits :: Patch -> PrettyPrintEnv -> NumberedOutput
type NumberedArgs = [String]
type ListDetailed = Bool
data HistoryTail
EndOfLog :: CausalHash -> HistoryTail
MergeTail :: CausalHash -> [CausalHash] -> HistoryTail
PageEnd :: CausalHash -> Int -> HistoryTail
data TestReportStats
CachedTests :: TotalCount -> CachedCount -> TestReportStats
NewlyComputed :: TestReportStats
data UndoFailureReason
CantUndoPastStart :: UndoFailureReason
CantUndoPastMerge :: UndoFailureReason
data ShareError
ShareErrorCheckAndSetPush :: CheckAndSetPushError -> ShareError
ShareErrorFastForwardPush :: FastForwardPushError -> ShareError
ShareErrorPull :: PullError -> ShareError
ShareErrorGetCausalHashByPath :: GetCausalHashByPathError -> ShareError
ShareErrorTransport :: CodeserverTransportError -> ShareError
isFailure :: Output -> Bool
isNumberedFailure :: NumberedOutput -> Bool
instance GHC.Show.Show Unison.Codebase.Editor.Output.HistoryTail
instance GHC.Show.Show Unison.Codebase.Editor.Output.TestReportStats
instance GHC.Show.Show Unison.Codebase.Editor.Output.UndoFailureReason

module Unison.CommandLine.Completion

-- | Constructs a list of <a>Completion</a>s from a query and completion
--   options by filtering them for prefix matches. A completion will be
--   selected if it's an exact match for a provided option.
exactComplete :: String -> [String] -> [Completion]

-- | Completes a term or type argument by prefix-matching against the
--   query.
prefixCompleteTermOrType :: forall m v a. MonadIO m => String -> Codebase m v a -> Absolute -> m [Completion]

-- | Completes a term argument by prefix-matching against the query.
prefixCompleteTerm :: forall m v a. MonadIO m => String -> Codebase m v a -> Absolute -> m [Completion]

-- | Completes a term or type argument by prefix-matching against the
--   query.
prefixCompleteType :: forall m v a. MonadIO m => String -> Codebase m v a -> Absolute -> m [Completion]

-- | Completes a patch argument by prefix-matching against the query.
prefixCompletePatch :: forall m v a. MonadIO m => String -> Codebase m v a -> Absolute -> m [Completion]

-- | The empty completor.
noCompletions :: MonadIO m => String -> Codebase m v a -> AuthenticatedHttpClient -> Absolute -> m [Completion]

-- | Completes a namespace argument by prefix-matching against the query.
prefixCompleteNamespace :: forall m v a. MonadIO m => String -> Codebase m v a -> Absolute -> m [Completion]
prettyCompletion :: Bool -> (String, Pretty ColorText) -> Completion
fixupCompletion :: String -> [Completion] -> [Completion]

-- | A completion func for use with Haskeline
haskelineTabComplete :: MonadIO m => Map String InputPattern -> Codebase m v a -> AuthenticatedHttpClient -> Absolute -> CompletionFunc m
sharePathCompletion :: MonadIO m => AuthenticatedHttpClient -> String -> m [Completion]
instance GHC.Classes.Ord Unison.CommandLine.Completion.CompletionType
instance GHC.Classes.Eq Unison.CommandLine.Completion.CompletionType
instance GHC.Show.Show Unison.CommandLine.Completion.CompletionType
instance GHC.Show.Show Unison.CommandLine.Completion.SearchResult
instance Data.Aeson.Types.FromJSON.FromJSON Unison.CommandLine.Completion.SearchResult

module Unison.CommandLine.InputPatterns
showPatternHelp :: InputPattern -> Pretty ColorText
patternName :: InputPattern -> Pretty ColorText
makeExample :: InputPattern -> [Pretty ColorText] -> Pretty ColorText
makeExampleNoBackticks :: InputPattern -> [Pretty ColorText] -> Pretty ColorText
makeExample' :: InputPattern -> Pretty ColorText
makeExampleEOS :: InputPattern -> [Pretty ColorText] -> Pretty ColorText
helpFor :: InputPattern -> Either (Pretty ColorText) Input
mergeBuiltins :: InputPattern
mergeIOBuiltins :: InputPattern
updateBuiltins :: InputPattern
todo :: InputPattern
load :: InputPattern
add :: InputPattern
previewAdd :: InputPattern
updateNoPatch :: InputPattern
update :: InputPattern
previewUpdate :: InputPattern
patch :: InputPattern
view :: InputPattern
viewGlobal :: InputPattern
display :: InputPattern
displayTo :: InputPattern
docs :: InputPattern
api :: InputPattern
ui :: InputPattern
undo :: InputPattern
viewByPrefix :: InputPattern
find :: InputPattern
findAll :: InputPattern
findGlobal :: InputPattern
find' :: String -> FindScope -> InputPattern
findShallow :: InputPattern
findVerbose :: InputPattern
findVerboseAll :: InputPattern
findPatch :: InputPattern
renameTerm :: InputPattern
renameType :: InputPattern
delete :: InputPattern
deleteTerm :: InputPattern
deleteType :: InputPattern
deleteTermReplacementCommand :: String
deleteTypeReplacementCommand :: String
deleteReplacement :: Bool -> InputPattern
deleteTermReplacement :: InputPattern
deleteTypeReplacement :: InputPattern
parseHashQualifiedName :: String -> Either (Pretty ColorText) (HashQualified Name)
aliasTerm :: InputPattern
aliasType :: InputPattern
aliasMany :: InputPattern
up :: InputPattern
cd :: InputPattern
back :: InputPattern
deleteNamespace :: InputPattern
deleteNamespaceForce :: InputPattern
deleteNamespaceParser :: Pretty ColorText -> Insistence -> [String] -> Either (Pretty ColorText) Input
deletePatch :: InputPattern
movePatch :: String -> String -> Either (Pretty ColorText) Input
copyPatch' :: String -> String -> Either (Pretty ColorText) Input
copyPatch :: InputPattern
renamePatch :: InputPattern
renameBranch :: InputPattern
history :: InputPattern
forkLocal :: InputPattern
resetRoot :: InputPattern
pullSilent :: InputPattern
pull :: InputPattern
pullWithoutHistory :: InputPattern
pullImpl :: String -> Verbosity -> PullMode -> Pretty ColorText -> InputPattern
pullExhaustive :: InputPattern
debugTabCompletion :: InputPattern
push :: InputPattern
pushCreate :: InputPattern
pushForce :: InputPattern
pushExhaustive :: InputPattern
createPullRequest :: InputPattern
loadPullRequest :: InputPattern
parseReadRemoteNamespace :: String -> String -> Either (Pretty ColorText) ReadRemoteNamespace
prettyPrintParseError :: String -> ParseErrorBundle Text Void -> Pretty ColorText
parseWriteGitRepo :: String -> String -> Either (Pretty ColorText) WriteGitRepo
parseWriteRemotePath :: String -> String -> Either (Pretty ColorText) WriteRemotePath
squashMerge :: InputPattern
mergeLocal :: InputPattern
diffNamespace :: InputPattern
previewMergeLocal :: InputPattern
replaceEdit :: (HashQualified Name -> HashQualified Name -> Maybe PatchPath -> Input) -> InputPattern
replace :: InputPattern
viewReflog :: InputPattern
edit :: InputPattern
topicNameArg :: ArgumentType
codebaseServerNameArg :: ArgumentType
helpTopics :: InputPattern
helpTopicsMap :: Map String (Pretty ColorText)
help :: InputPattern
quit :: InputPattern
viewPatch :: InputPattern
link :: InputPattern
links :: InputPattern
unlink :: InputPattern
names :: IsGlobal -> InputPattern
dependents :: InputPattern
dependencies :: InputPattern
namespaceDependencies :: InputPattern
debugNumberedArgs :: InputPattern
debugFileHashes :: InputPattern
debugDumpNamespace :: InputPattern
debugDumpNamespaceSimple :: InputPattern
debugClearWatchCache :: InputPattern
debugDoctor :: InputPattern
test :: InputPattern
testAll :: InputPattern
docsToHtml :: InputPattern
execute :: InputPattern
saveExecuteResult :: InputPattern
ioTest :: InputPattern
makeStandalone :: InputPattern
createAuthor :: InputPattern
gist :: InputPattern
authLogin :: InputPattern
printVersion :: InputPattern
validInputs :: [InputPattern]

-- | A map of all command patterns by pattern name or alias.
patternMap :: Map String InputPattern
visibleInputs :: [InputPattern]
commandNames :: [String]
commandNameArg :: ArgumentType
exactDefinitionArg :: ArgumentType
fuzzyDefinitionQueryArg :: ArgumentType
definitionQueryArg :: ArgumentType
exactDefinitionTypeQueryArg :: ArgumentType
exactDefinitionTermQueryArg :: ArgumentType
patchArg :: ArgumentType
namespaceArg :: ArgumentType

-- | Names of child branches of the branch, only gives options for one
--   <tt>layer</tt> deeper at a time.
childNamespaceNames :: Branch0 m -> [Text]
newNameArg :: ArgumentType
noCompletionsArg :: ArgumentType
gitUrlArg :: ArgumentType

-- | Refers to a namespace on some remote code host.
remoteNamespaceArg :: ArgumentType
collectNothings :: (a -> Maybe b) -> [a] -> [a]
explainRemote :: PushPull -> Pretty ColorText
showErrorFancy :: ShowErrorComponent e => ErrorFancy e -> String
showErrorItem :: ErrorItem (Token Text) -> String

module Unison.CommandLine.OutputMessages
type Pretty = Pretty ColorText
shortenDirectory :: FilePath -> IO FilePath
renderFileName :: FilePath -> IO Pretty
notifyNumbered :: NumberedOutput -> (Pretty, NumberedArgs)
undoTip :: Pretty ColorText
showListEdits :: Patch -> PrettyPrintEnv -> (Pretty ColorText, NumberedArgs)
prettyURI :: URI -> Pretty
prettyReadRemoteNamespace :: ReadRemoteNamespace -> Pretty
prettyWriteRemotePath :: WriteRemotePath -> Pretty
notifyUser :: FilePath -> Output -> IO Pretty
shareOrigin :: Text
prettyShareLink :: WriteShareRemotePath -> Pretty
prettyFilePath :: FilePath -> Pretty
prettyPath' :: Path' -> Pretty
prettyBranchId :: AbsBranchId -> Pretty
prettyRelative :: Relative -> Pretty
prettyAbsolute :: Absolute -> Pretty
prettySBH :: IsString s => ShortBranchHash -> Pretty s
prettyCausalHash :: IsString s => CausalHash -> Pretty s
prettyBase32Hex :: IsString s => Base32Hex -> Pretty s
prettyBase32Hex# :: IsString s => Base32Hex -> Pretty s
prettyHash :: IsString s => Hash -> Pretty s
prettyHash32 :: IsString s => Hash32 -> Pretty s
formatMissingStuff :: (Show tm, Show typ) => [(HashQualified Name, tm)] -> [(HashQualified Name, typ)] -> Pretty
displayDefinitions' :: Var v => Ord a1 => PrettyPrintEnvDecl -> Map Reference (DisplayObject () (Decl v a1)) -> Map Reference (DisplayObject (Type v a1) (Term v a1)) -> Pretty
displayRendered :: Maybe FilePath -> Pretty -> IO Pretty
displayDefinitions :: Var v => Ord a1 => Maybe FilePath -> PrettyPrintEnvDecl -> Map Reference (DisplayObject () (Decl v a1)) -> Map Reference (DisplayObject (Type v a1) (Term v a1)) -> IO Pretty
displayTestResults :: Bool -> PrettyPrintEnv -> [(Reference, Text)] -> [(Reference, Text)] -> Pretty
unsafePrettyTermResultSig' :: Var v => PrettyPrintEnv -> TermResult' v a -> Pretty
unsafePrettyTermResultSigFull' :: Var v => PrettyPrintEnv -> TermResult' v a -> Pretty
prettyTypeResultHeader' :: Var v => TypeResult' v a -> Pretty
prettyTypeResultHeaderFull' :: Var v => TypeResult' v a -> Pretty
prettyDeclTriple :: Var v => (HashQualified Name, Reference, DisplayObject () (Decl v a)) -> Pretty
prettyDeclPair :: Var v => PrettyPrintEnv -> (Reference, DisplayObject () (Decl v a)) -> Pretty
renderNameConflicts :: PrettyPrintEnv -> Names -> Numbered Pretty
renderEditConflicts :: PrettyPrintEnv -> Patch -> Numbered Pretty
type Numbered = State (Int, Seq String)
addNumberedArg :: String -> Numbered Int
formatNum :: Int -> Pretty
runNumbered :: Numbered a -> (a, NumberedArgs)
todoOutput :: Var v => PrettyPrintEnvDecl -> TodoOutput v a -> (Pretty, NumberedArgs)
listOfDefinitions :: Var v => FindScope -> PrettyPrintEnv -> ListDetailed -> [SearchResult' v a] -> IO Pretty
listOfLinks :: Var v => PrettyPrintEnv -> [(HashQualified Name, Maybe (Type v a))] -> IO Pretty
data ShowNumbers
ShowNumbers :: ShowNumbers
HideNumbers :: ShowNumbers

-- | <tt>ppe</tt> is just for rendering type signatures `oldPath, newPath
--   :: Path.Absolute` are just for producing fully-qualified numbered args
showDiffNamespace :: forall v. Var v => ShowNumbers -> PrettyPrintEnv -> AbsBranchId -> AbsBranchId -> BranchDiffOutput v Ann -> (Pretty, NumberedArgs)
noResults :: FindScope -> Pretty
listOfDefinitions' :: Var v => FindScope -> PrettyPrintEnv -> ListDetailed -> [SearchResult' v a] -> Pretty
watchPrinter :: Var v => Text -> PrettyPrintEnv -> Ann -> WatchKind -> Term v () -> IsCacheHit -> Pretty
filestatusTip :: Pretty
prettyDiff :: Diff -> Pretty
prettyTermName :: PrettyPrintEnv -> Referent -> Pretty
prettyTypeName :: PrettyPrintEnv -> Reference -> Pretty
prettyReadGitRepo :: ReadGitRepo -> Pretty
prettyWriteGitRepo :: WriteGitRepo -> Pretty
isTestOk :: Term v Ann -> Bool

-- | Get the list of numbered args corresponding to an endangerment map,
--   which is used by a few outputs. See <a>endangeredDependentsTable</a>.
numberedArgsForEndangerments :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> NumberedArgs

-- | Format and render all dependents which are endangered by references
--   going extinct.
endangeredDependentsTable :: PrettyPrintEnvDecl -> Map LabeledDependency (NESet LabeledDependency) -> Pretty ColorText

-- | Displays a full, non-truncated Branch.CausalHash to a string, e.g.
--   #abcdef
displayBranchHash :: CausalHash -> String
prettyHumanReadableTime :: UTCTime -> UTCTime -> Pretty

module Unison.CommandLine.DisplayValues
type Pretty = Pretty ColorText
displayTerm :: Monad m => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term Symbol ()))) -> (Referent -> m (Maybe (Type Symbol ()))) -> (Term Symbol () -> m (Maybe (Term Symbol ()))) -> (Reference -> m (Maybe (Decl Symbol ()))) -> Term Symbol () -> m Pretty
type ElideUnit = Bool
displayTerm' :: Monad m => ElideUnit -> PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term Symbol ()))) -> (Referent -> m (Maybe (Type Symbol ()))) -> (Term Symbol () -> m (Maybe (Term Symbol ()))) -> (Reference -> m (Maybe (Decl Symbol ()))) -> Term Symbol () -> m Pretty
displayPretty :: forall m. Monad m => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term Symbol ()))) -> (Referent -> m (Maybe (Type Symbol ()))) -> (Term Symbol () -> m (Maybe (Term Symbol ()))) -> (Reference -> m (Maybe (Decl Symbol ()))) -> Term Symbol () -> m Pretty
displayDoc :: forall v m. (Var v, Monad m) => PrettyPrintEnvDecl -> (Reference -> m (Maybe (Term v ()))) -> (Referent -> m (Maybe (Type v ()))) -> (Term v () -> m (Maybe (Term v ()))) -> (Reference -> m (Maybe (Decl v ()))) -> Term v () -> m Pretty
termName :: PrettyPrintEnv -> Referent -> Pretty
typeName :: PrettyPrintEnv -> Reference -> Pretty


-- | The main CLI monad.
module Unison.Cli.Monad

-- | The main command-line app monad.
--   
--   <ul>
--   <li>It is a reader monad of <a>Env</a>.</li>
--   <li>It is a state monad of <a>LoopState</a>.</li>
--   <li>It is a short-circuiting monad: a <tt>Cli</tt> computation can
--   short-circuit with success or failure.</li>
--   <li>It is a resource monad: resources can be acquired with
--   straight-line syntax, and will be released at the end of
--   do-block.</li>
--   <li>It is an IO monad: you can do IO things, but throwing synchronous
--   exceptions is discouraged. Use the built-in short-circuiting mechanism
--   instead.</li>
--   </ul>
--   
--   The <tt>r</tt> type variable is boilerplate. It starts out as
--   <tt>r</tt>, and grows an new <a>R</a> layer for each scoped action
--   (e.g. <a>with</a> / <a>label</a>). For this reason, whenever you find
--   yourself writing down an explicit type that has to carefully mention
--   how many <a>R</a> layers are inferred, you may prefer to use an
--   <tt>_</tt> (with <tt>PartialTypeSignatures</tt>) instead, as the
--   precise type is not very meaningful useful to a reader.
data Cli r a

-- | What a Cli action returns: a value, an instruction to continue
--   processing input, or an instruction to stop processing input.
data ReturnType a
Success :: a -> ReturnType a
Continue :: ReturnType a
HaltRepl :: ReturnType a

-- | Run a <tt>Cli</tt> action down to <tt>IO</tt>.
runCli :: Env -> LoopState -> Cli a a -> IO (ReturnType a, LoopState)

-- | The command-line app monad environment.
--   
--   Get the environment with <a>ask</a>.
data Env
Env :: AuthenticatedHttpClient -> Codebase IO Symbol Ann -> Config -> CredentialManager -> IO UniqueName -> (Text -> IO LoadSourceResult) -> (Output -> IO ()) -> (NumberedOutput -> IO NumberedArgs) -> Runtime Symbol -> Runtime Symbol -> Maybe BaseUrl -> UCMVersion -> Env
[$sel:authHTTPClient:Env] :: Env -> AuthenticatedHttpClient
[$sel:codebase:Env] :: Env -> Codebase IO Symbol Ann
[$sel:config:Env] :: Env -> Config
[$sel:credentialManager:Env] :: Env -> CredentialManager

-- | Generate a unique name.
[$sel:generateUniqueName:Env] :: Env -> IO UniqueName

-- | How to load source code.
[$sel:loadSource:Env] :: Env -> Text -> IO LoadSourceResult

-- | What to do with output for the user.
[$sel:notify:Env] :: Env -> Output -> IO ()

-- | What to do with numbered output for the user.
[$sel:notifyNumbered:Env] :: Env -> NumberedOutput -> IO NumberedArgs
[$sel:runtime:Env] :: Env -> Runtime Symbol
[$sel:sandboxedRuntime:Env] :: Env -> Runtime Symbol
[$sel:serverBaseUrl:Env] :: Env -> Maybe BaseUrl
[$sel:ucmVersion:Env] :: Env -> UCMVersion

-- | The command-line app monad mutable state.
--   
--   There's an additional pseudo <tt>"currentPath"</tt> field lens, for
--   convenience.
data LoopState
LoopState :: TMVar (Branch IO) -> CausalHash -> NonEmpty Absolute -> Maybe (FilePath, Bool) -> Maybe (TypecheckedUnisonFile Symbol Ann) -> Maybe Input -> NumberedArgs -> Maybe (Term Symbol Ann, Type Symbol Ann, TypecheckedUnisonFile Symbol Ann) -> LoopState
[$sel:root:LoopState] :: LoopState -> TMVar (Branch IO)
[$sel:lastSavedRootHash:LoopState] :: LoopState -> CausalHash
[$sel:currentPathStack:LoopState] :: LoopState -> NonEmpty Absolute
[$sel:latestFile:LoopState] :: LoopState -> Maybe (FilePath, Bool)
[$sel:latestTypecheckedFile:LoopState] :: LoopState -> Maybe (TypecheckedUnisonFile Symbol Ann)
[$sel:lastInput:LoopState] :: LoopState -> Maybe Input
[$sel:numberedArgs:LoopState] :: LoopState -> NumberedArgs
[$sel:lastRunResult:LoopState] :: LoopState -> Maybe (Term Symbol Ann, Type Symbol Ann, TypecheckedUnisonFile Symbol Ann)

-- | Create an initial loop state given a root branch and the current path.
loopState0 :: CausalHash -> TMVar (Branch IO) -> Absolute -> LoopState

-- | Lift an action of type <tt>IO (Either e a)</tt>, given a continuation
--   for <tt>e</tt>.
ioE :: IO (Either e a) -> (e -> Cli r a) -> Cli r a

-- | Wrap a continuation with <a>Cli</a>.
--   
--   Useful for resource acquisition:
--   
--   <pre>
--   with (bracket create destroy) \resource -&gt;
--     ...
--   </pre>
with :: (forall x. (a -> IO x) -> IO x) -> (a -> Cli (R r b) b) -> Cli r b

-- | A variant of <a>with</a> for actions that don't acquire a resource
--   (like <a>bracket_</a>).
with_ :: (forall x. IO x -> IO x) -> Cli (R r a) a -> Cli r a

-- | A variant of <a>with</a> for the variant of bracketing function that
--   may return a Left rather than call the provided continuation.
withE :: (forall x. (a -> IO x) -> IO (Either e x)) -> (Either e a -> Cli (R r b) b) -> Cli r b

-- | Create a label that can be jumped to.
--   
--   <pre>
--   x &lt;- label \j0 -&gt; do
--     ...
--     label \j1 -&gt; do
--       ...
--       j0 someValue
--       ... -- We don't get here
--     ... -- We don't get here
--   -- x is bound to someValue
--   </pre>
label :: forall r a. ((forall t b. Label (R r a) t => a -> Cli t b) -> Cli (R r a) a) -> Cli r a

-- | Short-circuit the processing of the current input.
returnEarly :: Output -> Cli r a

-- | Variant of <a>returnEarly</a> that doesn't take a final output
--   message.
returnEarlyWithoutOutput :: Cli r a

-- | Stop processing inputs from the user.
haltRepl :: Cli r a
respond :: Output -> Cli r ()
respondNumbered :: NumberedOutput -> Cli r ()

-- | Time an action.
time :: String -> Cli r a -> Cli r a

-- | The result of calling <a>$sel:loadSource:Env</a>.
data LoadSourceResult
InvalidSourceNameError :: LoadSourceResult
LoadError :: LoadSourceResult
LoadSuccess :: Text -> LoadSourceResult
class Label s t
data R a b
instance GHC.Generics.Generic Unison.Cli.Monad.LoopState
instance GHC.Generics.Generic Unison.Cli.Monad.Env
instance Control.Monad.State.Class.MonadState Unison.Cli.Monad.LoopState (Unison.Cli.Monad.Cli r)
instance Control.Monad.Reader.Class.MonadReader Unison.Cli.Monad.Env (Unison.Cli.Monad.Cli r)
instance Control.Monad.IO.Class.MonadIO (Unison.Cli.Monad.Cli r)
instance GHC.Base.Monad (Unison.Cli.Monad.Cli r)
instance GHC.Base.Applicative (Unison.Cli.Monad.Cli r)
instance GHC.Base.Functor (Unison.Cli.Monad.Cli r)
instance Unison.Cli.Monad.Label (Unison.Cli.Monad.R t x) (Unison.Cli.Monad.R t x)
instance Unison.Cli.Monad.Label s t => Unison.Cli.Monad.Label s (Unison.Cli.Monad.R t x)
instance GHC.Base.Functor f => GHC.OverloadedLabels.IsLabel "currentPath" ((Unison.Codebase.Path.Absolute -> f Unison.Codebase.Path.Absolute) -> Unison.Cli.Monad.LoopState -> f Unison.Cli.Monad.LoopState)

module Unison.Codebase.Editor.HandleInput.NamespaceDependencies

-- | Check the dependencies of all types, terms, and metadata in the
--   current namespace, returns a map of dependencies which do not have a
--   name within the current namespace, alongside the names of all of that
--   thing's dependents.
--   
--   This is non-transitive, i.e. only the first layer of external
--   dependencies is returned.
--   
--   So if my namespace depends on .base.Bag.map; which depends on
--   base.Map.mapKeys, only .base.Bag.map is returned unless some other
--   definition inside my namespace depends on base.Map.mapKeys directly.
--   
--   Returns a Set of names rather than using the PPE since we already have
--   the correct names in scope on this branch, and also want to list ALL
--   names of dependents, including aliases.
namespaceDependencies :: forall m r. Branch0 m -> Cli r (Map LabeledDependency (Set Name))

module Unison.Codebase.Editor.HandleInput.AuthLogin

-- | Direct the user through an authentication flow with the given server
--   and store the credentials in the provided credential manager.
authLogin :: CodeserverURI -> Cli r ()

-- | Checks if the user has valid auth for the given codeserver, and runs
--   through an authentication flow if not.
ensureAuthenticatedWithCodeserver :: CodeserverURI -> Cli r ()

module Unison.Cli.TypeCheck
typecheck :: [Type Symbol Ann] -> NamesWithHistory -> Text -> (Text, [Token Lexeme]) -> Cli r (Result (Seq (Note Symbol Ann)) (Either (UnisonFile Symbol Ann) (TypecheckedUnisonFile Symbol Ann)))
typecheckHelper :: MonadIO m => Codebase IO Symbol Ann -> IO UniqueName -> [Type Symbol Ann] -> NamesWithHistory -> Text -> (Text, [Token Lexeme]) -> m (Result (Seq (Note Symbol Ann)) (Either (UnisonFile Symbol Ann) (TypecheckedUnisonFile Symbol Ann)))
typecheckFile :: [Type Symbol Ann] -> UnisonFile Symbol Ann -> Cli r (Result (Seq (Note Symbol Ann)) (Either Names (TypecheckedUnisonFile Symbol Ann)))

module Unison.LSP.FileAnalysis

-- | Lex, parse, and typecheck a file.
checkFile :: HasUri d Uri => d -> Lsp (Maybe FileAnalysis)
fileAnalysisWorker :: Lsp ()
analyseFile :: Foldable f => Uri -> Text -> f (Note Symbol Ann) -> Lsp ([Diagnostic], [RangedCodeAction])
analyseNotes :: Foldable f => Uri -> PrettyPrintEnv -> String -> f (Note Symbol Ann) -> Lsp ([Diagnostic], [RangedCodeAction])
toRangeMap :: Foldable f => f (Range, a) -> IntervalMap Position [a]
getFileAnalysis :: Uri -> Lsp (Maybe FileAnalysis)
ppeForFile :: Uri -> Lsp PrettyPrintEnv

module Unison.LSP.FoldingRange
foldingRangeRequest :: RequestMessage 'TextDocumentFoldingRange -> (Either ResponseError (ResponseResult 'TextDocumentFoldingRange) -> Lsp ()) -> Lsp ()

-- | Return a folding range for each top-level definition
foldingRangesForFile :: Uri -> Lsp [FoldingRange]

module Unison.LSP.CodeAction

-- | Computes code actions for a document.
codeActionHandler :: RequestMessage 'TextDocumentCodeAction -> (Either ResponseError (ResponseResult 'TextDocumentCodeAction) -> Lsp ()) -> Lsp ()

module Unison.LSP
getLspPort :: IO String

-- | Spawn an LSP server on the configured port.
spawnLsp :: Codebase IO Symbol Ann -> Runtime Symbol -> STM (Branch IO) -> STM Absolute -> IO ()
serverDefinition :: MVar VFS -> Codebase IO Symbol Ann -> Runtime Symbol -> Scope -> STM (Branch IO) -> STM Absolute -> ServerDefinition Config

-- | Detect user LSP configuration changes.
lspOnConfigurationChange :: Config -> Value -> Either Text Config
lspDefaultConfig :: Config

-- | Initialize any context needed by the LSP server
lspDoInitialize :: MVar VFS -> Codebase IO Symbol Ann -> Runtime Symbol -> Scope -> STM (Branch IO) -> STM Absolute -> LanguageContextEnv Config -> Message 'Initialize -> IO (Either ResponseError Env)

-- | LSP request handlers that don't register/unregister dynamically
lspStaticHandlers :: Handlers Lsp

-- | LSP request handlers
lspRequestHandlers :: SMethodMap (ClientMessageHandler Lsp 'Request)

-- | LSP notification handlers
lspNotificationHandlers :: SMethodMap (ClientMessageHandler Lsp 'Notification)

-- | A natural transformation into IO, required by the LSP lib.
lspInterpretHandler :: Env -> Lsp <~> IO
lspOptions :: Options


-- | This module contains miscellaneous helper utils for rote actions in
--   the Cli monad, like resolving a relative path to an absolute path, per
--   the current path.
module Unison.Cli.MonadUtils

-- | Lookup a config value by key.
getConfig :: Configured a => Text -> Cli r (Maybe a)

-- | Get the current path.
getCurrentPath :: Cli r Absolute

-- | Resolve a <tt>Path'</tt> to a <tt>Path.Absolute</tt>, per the current
--   path.
resolvePath' :: Path' -> Cli r Absolute

-- | Resolve a path split, per the current path.
resolveSplit' :: (Path', a) -> Cli r (Absolute, a)

-- | Resolve an <tt>AbsBranchId</tt> to the corresponding <tt>Branch
--   IO</tt>, or fail if no such branch hash is found. (Non-existent
--   branches by path are OK - the empty branch will be returned).
resolveAbsBranchId :: AbsBranchId -> Cli r (Branch IO)

-- | Resolve a <tt>ShortBranchHash</tt> to the corresponding <tt>Branch
--   IO</tt>, or fail if no such branch hash is found.
resolveShortBranchHash :: ShortBranchHash -> Cli r (Branch IO)

-- | Get the root branch.
getRootBranch :: Cli r (Branch IO)

-- | Set a new root branch. Note: This does _not_ update the codebase, the
--   caller is responsible for that.
setRootBranch :: Branch IO -> Cli r ()

-- | Get the root branch.
modifyRootBranch :: (Branch IO -> Branch IO) -> Cli r (Branch IO)

-- | Get the root branch0.
getRootBranch0 :: Cli r (Branch0 IO)

-- | Get the current branch.
getCurrentBranch :: Cli r (Branch IO)

-- | Get the current branch0.
getCurrentBranch0 :: Cli r (Branch0 IO)

-- | Get the branch at an absolute path.
getBranchAt :: Absolute -> Cli r (Branch IO)

-- | Get the branch0 at an absolute path.
getBranch0At :: Absolute -> Cli r (Branch0 IO)

-- | Get the last saved root hash.
getLastSavedRootHash :: Cli r CausalHash

-- | Set a new root branch. Note: This does _not_ update the codebase, the
--   caller is responsible for that.
setLastSavedRootHash :: CausalHash -> Cli r ()

-- | Get the maybe-branch at an absolute path.
getMaybeBranchAt :: Absolute -> Cli r (Maybe (Branch IO))

-- | Get the branch at an absolute or relative path, or return early if
--   there's no such branch.
expectBranchAtPath' :: Path' -> Cli r (Branch IO)

-- | Assert that there's "no branch" at an absolute or relative path, or
--   return early if there is one, where "no branch" means either there's
--   actually no branch, or there is a branch whose head is empty (i.e. it
--   may have a history, but no current terms/types etc).
assertNoBranchAtPath' :: Path' -> Cli r ()

-- | Check if there's a branch at an absolute or relative path
--   
--   "no branch" means either there's actually no branch, or there is a
--   branch whose head is empty (i.e. it may have a history, but no current
--   terms/types etc).
branchExistsAtPath' :: Path' -> Cli r Bool
stepAt' :: Text -> (Path, Branch0 IO -> Cli r (Branch0 IO)) -> Cli r Bool
stepAt :: Text -> (Path, Branch0 IO -> Branch0 IO) -> Cli r ()
stepAtM :: Text -> (Path, Branch0 IO -> IO (Branch0 IO)) -> Cli r ()
stepAtNoSync' :: (Path, Branch0 IO -> Cli r (Branch0 IO)) -> Cli r Bool
stepAtNoSync :: (Path, Branch0 IO -> Branch0 IO) -> Cli r ()
stepManyAt :: Foldable f => Text -> f (Path, Branch0 IO -> Branch0 IO) -> Cli r ()
stepManyAtMNoSync :: Foldable f => f (Path, Branch0 IO -> IO (Branch0 IO)) -> Cli r ()
stepManyAtNoSync :: Foldable f => f (Path, Branch0 IO -> Branch0 IO) -> Cli r ()

-- | Sync the in-memory root branch.
syncRoot :: Text -> Cli r ()
updateRoot :: Branch IO -> Text -> Cli r ()

-- | Update a branch at the given path, returning <a>True</a> if an update
--   occurred and false otherwise
updateAtM :: Text -> Absolute -> (Branch IO -> Cli r (Branch IO)) -> Cli r Bool

-- | Update a branch at the given path, returning <a>True</a> if an update
--   occurred and false otherwise
updateAt :: Text -> Absolute -> (Branch IO -> Branch IO) -> Cli r Bool
getTermsAt :: (Absolute, HQSegment) -> Cli r (Set Referent)
getTypesAt :: (Absolute, HQSegment) -> Cli r (Set TypeReference)
defaultPatchNameSegment :: NameSegment

-- | The default patch path.
defaultPatchPath :: Split'

-- | Get the patch at a path, or the empty patch if there's no such patch.
getPatchAt :: Split' -> Cli r Patch

-- | Get the patch at a path.
getMaybePatchAt :: Split' -> Cli r (Maybe Patch)

-- | Get the patch at a path, or return early if there's no such patch.
expectPatchAt :: Split' -> Cli r Patch

-- | Assert that there's no patch at a path, or return early if there is
--   one.
assertNoPatchAt :: Split' -> Cli r ()
getLatestFile :: Cli r (Maybe (FilePath, Bool))
expectLatestFile :: Cli r (FilePath, Bool)

-- | Get the latest typechecked unison file.
getLatestTypecheckedFile :: Cli r (Maybe (TypecheckedUnisonFile Symbol Ann))

-- | Get the latest typechecked unison file, or return early if there isn't
--   one.
expectLatestTypecheckedFile :: Cli r (TypecheckedUnisonFile Symbol Ann)

module Unison.Codebase.Editor.Propagate
propagateAndApply :: Patch -> Branch0 IO -> Cli r (Branch0 IO)
instance GHC.Show.Show v => GHC.Show.Show (Unison.Codebase.Editor.Propagate.Edits v)
instance U.Core.ABT.Var.Var v => GHC.Classes.Eq (Unison.Codebase.Editor.Propagate.Edits v)

module Unison.Codebase.Editor.HandleInput.MoveBranch

-- | Moves a branch and its history from one location to another, and saves
--   the new root branch.
doMoveBranch :: forall r. Text -> Bool -> Path' -> Path' -> Cli r ()


-- | Utilities that have to do with constructing pretty-print environments,
--   given stateful information in the Cli monad state/environment, such as
--   the current path.
module Unison.Cli.PrettyPrintUtils
prettyPrintEnvDecl :: NamesWithHistory -> Cli r PrettyPrintEnvDecl

-- | Get a pretty print env decl for the current names at the current path.
currentPrettyPrintEnvDecl :: (Path -> NameScoping) -> Cli r PrettyPrintEnvDecl


-- | Helpers/utils that have to do with namespace diffs.
module Unison.Codebase.Editor.HandleInput.NamespaceDiffUtils
diffHelper :: Branch0 IO -> Branch0 IO -> Cli r (PrettyPrintEnv, BranchDiffOutput Symbol Ann)


-- | Helpers<i>utils that have to do with term</i>type metadata.
module Unison.Codebase.Editor.HandleInput.MetadataUtils
addDefaultMetadata :: SlurpComponent Symbol -> Cli r ()

-- | Add/remove links between definitions and metadata. <tt>silent</tt>
--   controls whether this produces any output to the user. <tt>srcs</tt>
--   is (names of the) definitions to pass to <a>op</a> <tt>mdValues</tt>
--   is (names of the) metadata to pass to <a>op</a> <a>op</a> is the
--   operation to add<i>remove</i>alter metadata mappings. e.g.
--   <a>insert</a> is passed to add metadata links.
manageLinks :: Bool -> [HQSplit'] -> [HashQualified Name] -> (forall r. Ord r => (r, Type, Value) -> Star r NameSegment -> Star r NameSegment) -> Cli r ()


-- | Utilities that have to do with constructing names objects.
module Unison.Cli.NamesUtils
basicParseNames :: Cli r Names
basicPrettyPrintNamesA :: Cli r Names

-- | Produce a <a>Names</a> needed to display all the hashes used in the
--   given file.
displayNames :: Var v => TypecheckedUnisonFile v a -> Cli r NamesWithHistory
findHistoricalHQs :: Set (HashQualified Name) -> Cli r Names
getBasicPrettyPrintNames :: Cli r Names
makeHistoricalParsingNames :: Set (HashQualified Name) -> Cli r NamesWithHistory
makePrintNamesFromLabeled' :: Set LabeledDependency -> Cli r NamesWithHistory
makeShadowedPrintNamesFromHQ :: Set (HashQualified Name) -> Names -> Cli r NamesWithHistory

module Unison.Codebase.Editor.HandleInput.Update

-- | Handle an <tt>update</tt> command.
handleUpdate :: Input -> OptionalPatch -> Set Name -> Cli r ()
doSlurpAdds :: forall m v. (Monad m, Var v) => SlurpComponent v -> TypecheckedUnisonFile v Ann -> Branch0 m -> Branch0 m

module Unison.Codebase.Editor.HandleInput
loop :: Either Event Input -> Cli r ()

module Unison.CommandLine.Main
main :: FilePath -> Welcome -> Absolute -> (Config, IO ()) -> [Either Event Input] -> Runtime Symbol -> Runtime Symbol -> Codebase IO Symbol Ann -> Maybe BaseUrl -> UCMVersion -> (Branch IO -> STM ()) -> (Absolute -> STM ()) -> IO ()

module Unison.Codebase.TranscriptParser
data Stanza
Ucm :: Hidden -> ExpectingError -> [UcmLine] -> Stanza
Unison :: Hidden -> ExpectingError -> Maybe ScratchFileName -> Text -> Stanza
API :: [APIRequest] -> Stanza
UnprocessedFence :: FenceType -> Text -> Stanza
Unfenced :: Text -> Stanza
type FenceType = Text
type ExpectingError = Bool
data Hidden
data TranscriptError
TranscriptRunFailure :: Text -> TranscriptError
TranscriptParseError :: Text -> TranscriptError
data UcmLine
UcmCommand :: Absolute -> Text -> UcmLine
UcmComment :: Text -> UcmLine
withTranscriptRunner :: forall m r. MonadUnliftIO m => UCMVersion -> Maybe FilePath -> (TranscriptRunner -> m r) -> m r
parse :: String -> Text -> Either TranscriptError [Stanza]
parseFile :: FilePath -> IO (Either TranscriptError [Stanza])
instance GHC.Show.Show Unison.Codebase.TranscriptParser.Hidden
instance GHC.Classes.Eq Unison.Codebase.TranscriptParser.Hidden
instance GHC.Exception.Type.Exception Unison.Codebase.TranscriptParser.TranscriptError
instance GHC.Show.Show Unison.Codebase.TranscriptParser.TranscriptError
instance GHC.Show.Show Unison.Codebase.TranscriptParser.Stanza
instance GHC.Show.Show Unison.Codebase.TranscriptParser.APIRequest
instance GHC.Show.Show Unison.Codebase.TranscriptParser.UcmLine
