-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell library for the Microsoft Language Server Protocol
--   
--   An implementation of the types, and basic message server to allow
--   language implementors to support the Language Server Protocol for
--   their specific language.
--   
--   An example of this is for Haskell via the Haskell Language Server, at
--   <a>https://github.com/haskell/haskell-language-server</a>
@package lsp
@version 1.5.0.0

module Language.LSP.Diagnostics
type DiagnosticStore = HashMap NormalizedUri StoreItem
type DiagnosticsBySource = Map (Maybe DiagnosticSource) (SortedList Diagnostic)
data StoreItem
StoreItem :: TextDocumentVersion -> DiagnosticsBySource -> StoreItem
partitionBySource :: [Diagnostic] -> DiagnosticsBySource
flushBySource :: DiagnosticStore -> Maybe DiagnosticSource -> DiagnosticStore
updateDiagnostics :: DiagnosticStore -> NormalizedUri -> TextDocumentVersion -> DiagnosticsBySource -> DiagnosticStore
getDiagnosticParamsFor :: Int -> DiagnosticStore -> NormalizedUri -> Maybe PublishDiagnosticsParams
instance GHC.Classes.Eq Language.LSP.Diagnostics.StoreItem
instance GHC.Show.Show Language.LSP.Diagnostics.StoreItem


-- | Handles the <a>Language.LSP.Types.TextDocumentDidChange</a> /
--   <a>Language.LSP.Types.TextDocumentDidOpen</a> /
--   <a>Language.LSP.Types.TextDocumentDidClose</a> messages to keep an
--   in-memory <tt>filesystem</tt> of the current client workspace. The
--   server can access and edit files in the client workspace by operating
--   on the <a>VFS</a> in <a>LspFuncs</a>.
module Language.LSP.VFS
data VFS
VFS :: !Map NormalizedUri VirtualFile -> !FilePath -> VFS
[$sel:_vfsMap:VFS] :: VFS -> !Map NormalizedUri VirtualFile

-- | This is where all the temporary files will be written to
[$sel:_vfsTempDir:VFS] :: VFS -> !FilePath
vfsMap :: HasVfsMap s a => Lens' s a
vfsTempDir :: HasVfsTempDir s a => Lens' s a
data VirtualFile
VirtualFile :: !Int32 -> !Int -> !Rope -> VirtualFile

-- | The LSP version of the document
[$sel:_lsp_version:VirtualFile] :: VirtualFile -> !Int32

-- | This number is only incremented whilst the file remains in the map.
[$sel:_file_version:VirtualFile] :: VirtualFile -> !Int

-- | The full contents of the document
[$sel:_file_text:VirtualFile] :: VirtualFile -> !Rope
lsp_version :: HasLsp_version s a => Lens' s a
file_version :: HasFile_version s a => Lens' s a
file_text :: HasFile_text s a => Lens' s a
virtualFileText :: VirtualFile -> Text
virtualFileVersion :: VirtualFile -> Int32
data VfsLog
SplitInsideCodePoint :: Position -> Rope -> VfsLog
URINotFound :: NormalizedUri -> VfsLog
Opening :: NormalizedUri -> VfsLog
Closing :: NormalizedUri -> VfsLog
PersistingFile :: NormalizedUri -> FilePath -> VfsLog
CantRecursiveDelete :: NormalizedUri -> VfsLog
DeleteNonExistent :: NormalizedUri -> VfsLog
initVFS :: (VFS -> IO r) -> IO r

-- | Applies the changes from a <a>DidOpenTextDocument</a> to the
--   <a>VFS</a>
openVFS :: MonadState VFS m => LogAction m (WithSeverity VfsLog) -> Message 'TextDocumentDidOpen -> m ()

-- | Applies a <tt>DidChangeTextDocumentNotification</tt> to the <a>VFS</a>
changeFromClientVFS :: MonadState VFS m => LogAction m (WithSeverity VfsLog) -> Message 'TextDocumentDidChange -> m ()

-- | Applies the changes from a <tt>ApplyWorkspaceEditRequest</tt> to the
--   <a>VFS</a>
changeFromServerVFS :: forall m. MonadState VFS m => LogAction m (WithSeverity VfsLog) -> Message 'WorkspaceApplyEdit -> m ()

-- | Write a virtual file to a temporary file if it exists in the VFS.
persistFileVFS :: MonadIO m => LogAction m (WithSeverity VfsLog) -> VFS -> NormalizedUri -> Maybe (FilePath, m ())
closeVFS :: MonadState VFS m => LogAction m (WithSeverity VfsLog) -> Message 'TextDocumentDidClose -> m ()

-- | A position, like a <a>Position</a>, but where the offsets in the line
--   are measured in Unicode code points instead of UTF-16 code units.
data CodePointPosition
CodePointPosition :: UInt -> UInt -> CodePointPosition

-- | Line position in a document (zero-based).
[$sel:_line:CodePointPosition] :: CodePointPosition -> UInt

-- | Character offset on a line in a document in *code points*
--   (zero-based).
[$sel:_character:CodePointPosition] :: CodePointPosition -> UInt
line :: HasLine s a => Lens' s a
character :: HasCharacter s a => Lens' s a

-- | Given a virtual file, translate a <a>CodePointPosition</a> in that
--   file into a <a>Position</a> in that file.
--   
--   Will return <a>Nothing</a> if the requested position is out of bounds
--   of the document.
--   
--   Logarithmic in the number of lines in the document, and linear in the
--   length of the line containing the position.
codePointPositionToPosition :: VirtualFile -> CodePointPosition -> Maybe Position

-- | Given a virtual file, translate a <a>Position</a> in that file into a
--   <a>CodePointPosition</a> in that file.
--   
--   Will return <a>Nothing</a> if the requested position lies inside a
--   code point, or if it is out of bounds of the document.
--   
--   Logarithmic in the number of lines in the document, and linear in the
--   length of the line containing the position.
positionToCodePointPosition :: VirtualFile -> Position -> Maybe CodePointPosition

-- | A range, like a <a>Range</a>, but where the offsets in the line are
--   measured in Unicode code points instead of UTF-16 code units.
data CodePointRange
CodePointRange :: CodePointPosition -> CodePointPosition -> CodePointRange

-- | The range's start position.
[$sel:_start:CodePointRange] :: CodePointRange -> CodePointPosition

-- | The range's end position.
[$sel:_end:CodePointRange] :: CodePointRange -> CodePointPosition
start :: HasStart s a => Lens' s a
end :: HasEnd s a => Lens' s a

-- | Given a virtual file, translate a <a>CodePointRange</a> in that file
--   into a <a>Range</a> in that file.
--   
--   Will return <a>Nothing</a> if any of the positions are out of bounds
--   of the document.
--   
--   Logarithmic in the number of lines in the document, and linear in the
--   length of the lines containing the positions.
codePointRangeToRange :: VirtualFile -> CodePointRange -> Maybe Range

-- | Given a virtual file, translate a <a>Range</a> in that file into a
--   <a>CodePointRange</a> in that file.
--   
--   Will return <a>Nothing</a> if any of the positions are out of bounds
--   of the document.
--   
--   Logarithmic in the number of lines in the document, and linear in the
--   length of the lines containing the positions.
rangeToCodePointRange :: VirtualFile -> Range -> Maybe CodePointRange
rangeLinesFromVfs :: VirtualFile -> Range -> Text

-- | Describes the line at the current cursor position
data PosPrefixInfo
PosPrefixInfo :: !Text -> !Text -> !Text -> !Position -> PosPrefixInfo

-- | The full contents of the line the cursor is at
[$sel:fullLine:PosPrefixInfo] :: PosPrefixInfo -> !Text

-- | If any, the module name that was typed right before the cursor
--   position. For example, if the user has typed "Data.Maybe.from", then
--   this property will be <a>Data.Maybe</a>
[$sel:prefixModule:PosPrefixInfo] :: PosPrefixInfo -> !Text

-- | The word right before the cursor position, after removing the module
--   part. For example if the user has typed "Data.Maybe.from", then this
--   property will be "from"
[$sel:prefixText:PosPrefixInfo] :: PosPrefixInfo -> !Text

-- | The cursor position
[$sel:cursorPos:PosPrefixInfo] :: PosPrefixInfo -> !Position
getCompletionPrefix :: Monad m => Position -> VirtualFile -> m (Maybe PosPrefixInfo)

-- | Apply the list of changes. Changes should be applied in the order that
--   they are received from the client.
applyChanges :: Monad m => LogAction m (WithSeverity VfsLog) -> Rope -> [TextDocumentContentChangeEvent] -> m Rope
applyChange :: Monad m => LogAction m (WithSeverity VfsLog) -> Rope -> TextDocumentContentChangeEvent -> m Rope

-- | Given a <a>Rope</a>, start and end positions, and some new text,
--   replace the given range with the new text. If the given positions lie
--   within a code point then this does nothing (returns the original
--   <a>Rope</a>) and logs.
changeChars :: Monad m => LogAction m (WithSeverity VfsLog) -> Rope -> Position -> Position -> Text -> m Rope
instance GHC.Classes.Eq Language.LSP.VFS.PosPrefixInfo
instance GHC.Show.Show Language.LSP.VFS.PosPrefixInfo
instance Language.LSP.VFS.HasStart Language.LSP.VFS.CodePointRange Language.LSP.VFS.CodePointPosition
instance Language.LSP.VFS.HasEnd Language.LSP.VFS.CodePointRange Language.LSP.VFS.CodePointPosition
instance Language.LSP.VFS.HasLine Language.LSP.VFS.CodePointPosition Language.LSP.Types.Common.UInt
instance Language.LSP.VFS.HasCharacter Language.LSP.VFS.CodePointPosition Language.LSP.Types.Common.UInt
instance GHC.Classes.Ord Language.LSP.VFS.CodePointPosition
instance GHC.Classes.Eq Language.LSP.VFS.CodePointPosition
instance GHC.Read.Read Language.LSP.VFS.CodePointPosition
instance GHC.Show.Show Language.LSP.VFS.CodePointPosition
instance GHC.Classes.Ord Language.LSP.VFS.CodePointRange
instance GHC.Classes.Eq Language.LSP.VFS.CodePointRange
instance GHC.Read.Read Language.LSP.VFS.CodePointRange
instance GHC.Show.Show Language.LSP.VFS.CodePointRange
instance Language.LSP.VFS.HasVfsTempDir Language.LSP.VFS.VFS GHC.IO.FilePath
instance Language.LSP.VFS.HasVfsMap Language.LSP.VFS.VFS (Data.Map.Internal.Map Language.LSP.Types.Uri.NormalizedUri Language.LSP.VFS.VirtualFile)
instance Language.LSP.VFS.HasLsp_version Language.LSP.VFS.VirtualFile GHC.Int.Int32
instance Language.LSP.VFS.HasFile_version Language.LSP.VFS.VirtualFile GHC.Types.Int
instance Language.LSP.VFS.HasFile_text Language.LSP.VFS.VirtualFile Data.Text.Utf16.Rope.Rope
instance GHC.Show.Show Language.LSP.VFS.VirtualFile
instance GHC.Show.Show Language.LSP.VFS.VFS
instance GHC.Show.Show Language.LSP.VFS.VfsLog
instance Prettyprinter.Internal.Pretty Language.LSP.VFS.VfsLog

module Language.LSP.Logging

-- | Logs messages to the client via <tt>window/showMessage</tt>.
logToShowMessage :: MonadLsp c m => LogAction m (WithSeverity Text)

-- | Logs messages to the client via <tt>window/logMessage</tt>.
logToLogMessage :: MonadLsp c m => LogAction m (WithSeverity Text)

-- | A <tt>sensible</tt> log action for logging messages to the client:
--   
--   <ul>
--   <li>Shows <a>Error</a> logs to the user via
--   <tt>window/showMessage</tt></li>
--   <li>Logs <a>Info</a> and above logs in the client via
--   <tt>window/logMessage</tt></li>
--   </ul>
--   
--   If you want finer control (e.g. the ability to log <a>Debug</a> logs
--   based on a flag, or similar), then do not use this and write your own
--   based on <a>logToShowMessage</a> and <a>logToLogMessage</a>.
defaultClientLogger :: MonadLsp c m => LogAction m (WithSeverity Text)

module Language.LSP.Server

-- | Convenience function for <a>runServerWithHandles</a> which: (1) reads
--   from stdin; (2) writes to stdout; and (3) logs to stderr and to the
--   client, with some basic filtering.
runServer :: forall config. ServerDefinition config -> IO Int

-- | Starts listening and sending requests and responses using the
--   specified I/O.
runServerWith :: LogAction IO (WithSeverity LspServerLog) -> LogAction (LspM config) (WithSeverity LspServerLog) -> IO ByteString -> (ByteString -> IO ()) -> ServerDefinition config -> IO Int

-- | Starts a language server over the specified handles. This function
--   will return once the <tt>exit</tt> notification is received.
runServerWithHandles :: LogAction IO (WithSeverity LspServerLog) -> LogAction (LspM config) (WithSeverity LspServerLog) -> Handle -> Handle -> ServerDefinition config -> IO Int
data LspServerLog
LspProcessingLog :: LspProcessingLog -> LspServerLog
DecodeInitializeError :: String -> LspServerLog
HeaderParseFail :: [String] -> String -> LspServerLog
EOF :: LspServerLog
Starting :: LspServerLog
ParsedMsg :: Text -> LspServerLog
SendMsg :: Text -> LspServerLog
data VFSData
VFSData :: !VFS -> !Map FilePath FilePath -> VFSData
[vfsData] :: VFSData -> !VFS
[reverseMap] :: VFSData -> !Map FilePath FilePath

-- | Contains all the callbacks to use for initialized the language server.
--   it is parameterized over a config type variable representing the type
--   for the specific configuration data the language server needs to use.
data ServerDefinition config
ServerDefinition :: config -> (config -> Value -> Either Text config) -> (LanguageContextEnv config -> Message Initialize -> IO (Either ResponseError a)) -> Handlers m -> (a -> m <~> IO) -> Options -> ServerDefinition config

-- | The default value we initialize the config variable to.
[defaultConfig] :: ServerDefinition config -> config

-- | <tt>onConfigurationChange oldConfig newConfig</tt> is called whenever
--   the clients sends a message with a changed client configuration. This
--   callback should return either the parsed configuration data or an
--   error indicating what went wrong. The parsed configuration object will
--   be stored internally and can be accessed via <tt>config</tt>. It is
--   also called on the <tt>initializationOptions</tt> field of the
--   InitializeParams
[onConfigurationChange] :: ServerDefinition config -> config -> Value -> Either Text config

-- | Called *after* receiving the <tt>initialize</tt> request and *before*
--   returning the response. This callback will be invoked to offer the
--   language server implementation the chance to create any processes or
--   start new threads that may be necessary for the server lifecycle. It
--   can also return an error in the initialization if necessary.
[doInitialize] :: ServerDefinition config -> LanguageContextEnv config -> Message Initialize -> IO (Either ResponseError a)

-- | Handlers for any methods you want to statically support. The handlers
--   here cannot be unregistered during the server's lifetime and will be
--   registered statically in the initialize request.
[staticHandlers] :: ServerDefinition config -> Handlers m

-- | How to run the handlers in your own monad of choice, <tt>m</tt>. It is
--   passed the result of <a>doInitialize</a>, so typically you will want
--   to thread along the <a>LanguageContextEnv</a> as well as any other
--   state you need to run your monad. <tt>m</tt> should most likely be
--   built on top of <a>LspT</a>.
--   
--   <pre>
--   ServerDefinition { ...
--   , doInitialize = env _req -&gt; pure $ Right env
--   , interpretHandler = env -&gt; Iso
--      (runLspT env) -- how to convert from IO ~&gt; m
--      liftIO        -- how to convert from m ~&gt; IO
--   }
--   </pre>
[interpretHandler] :: ServerDefinition config -> a -> m <~> IO

-- | Configurable options for the server's capabilities.
[options] :: ServerDefinition config -> Options

-- | A mapping from methods to the static <a>Handler</a>s that should be
--   used to handle responses when they come in from the client. To build
--   up a <a>Handlers</a>, you should <a>mconcat</a> a list of
--   <a>notificationHandler</a> and <a>requestHandler</a>s:
--   
--   <pre>
--   mconcat [
--     notificationHandler SInitialized $ notif -&gt; pure ()
--   , requestHandler STextDocumentHover $ req responder -&gt; pure ()
--   ]
--   </pre>
data Handlers m
Handlers :: !SMethodMap (ClientMessageHandler m Request) -> !SMethodMap (ClientMessageHandler m Notification) -> Handlers m
[reqHandlers] :: Handlers m -> !SMethodMap (ClientMessageHandler m Request)
[notHandlers] :: Handlers m -> !SMethodMap (ClientMessageHandler m Notification)

-- | The type of a handler that handles requests and notifications coming
--   in from the server or client
type family Handler (f :: Type -> Type) (m :: Method from t) = (result :: Type) | result -> f t m
transmuteHandlers :: (m <~> n) -> Handlers m -> Handlers n
mapHandlers :: (forall (a :: Method FromClient Request). Handler m a -> Handler n a) -> (forall (a :: Method FromClient Notification). Handler m a -> Handler n a) -> Handlers m -> Handlers n
notificationHandler :: forall (m :: Method FromClient Notification) f. SMethod m -> Handler f m -> Handlers f
requestHandler :: forall (m :: Method FromClient Request) f. SMethod m -> Handler f m -> Handlers f

-- | Wrapper to restrict <a>Handler</a>s to <a>FromClient</a>
--   <a>Method</a>s
newtype ClientMessageHandler f (t :: MethodType) (m :: Method FromClient t)
ClientMessageHandler :: Handler f m -> ClientMessageHandler f (t :: MethodType) (m :: Method FromClient t)

-- | Language Server Protocol options that the server may configure. If you
--   set handlers for some requests, you may need to set some of these
--   options.
data Options
Options :: Maybe TextDocumentSyncOptions -> Maybe [Char] -> Maybe [Char] -> Maybe [Char] -> Maybe [Char] -> Maybe [CodeActionKind] -> Maybe (NonEmpty Char) -> Maybe [Text] -> Maybe ServerInfo -> Options
[textDocumentSync] :: Options -> Maybe TextDocumentSyncOptions

-- | The characters that trigger completion automatically.
[completionTriggerCharacters] :: Options -> Maybe [Char]

-- | The list of all possible characters that commit a completion. This
--   field can be used if clients don't support individual commit
--   characters per completion item. See
--   <a>$sel:_commitCharactersSupport:CompletionItemClientCapabilities</a>.
[completionAllCommitCharacters] :: Options -> Maybe [Char]

-- | The characters that trigger signature help automatically.
[signatureHelpTriggerCharacters] :: Options -> Maybe [Char]

-- | List of characters that re-trigger signature help. These trigger
--   characters are only active when signature help is already showing. All
--   trigger characters are also counted as re-trigger characters.
[signatureHelpRetriggerCharacters] :: Options -> Maybe [Char]

-- | CodeActionKinds that this server may return. The list of kinds may be
--   generic, such as <a>Refactor</a>, or the server may list out every
--   specific kind they provide.
[codeActionKinds] :: Options -> Maybe [CodeActionKind]

-- | The list of characters that triggers on type formatting. If you set
--   <tt>documentOnTypeFormattingHandler</tt>, you **must** set this. The
--   first character is mandatory, so a <a>NonEmpty</a> should be passed.
[documentOnTypeFormattingTriggerCharacters] :: Options -> Maybe (NonEmpty Char)

-- | The commands to be executed on the server. If you set
--   <tt>executeCommandHandler</tt>, you **must** set this.
[executeCommandCommands] :: Options -> Maybe [Text]

-- | Information about the server that can be advertised to the client.
[serverInfo] :: Options -> Maybe ServerInfo
defaultOptions :: Options
newtype LspT config m a
LspT :: ReaderT (LanguageContextEnv config) m a -> LspT config m a
[unLspT] :: LspT config m a -> ReaderT (LanguageContextEnv config) m a
type LspM config = LspT config IO
class MonadUnliftIO m => MonadLsp config m | m -> config
getLspEnv :: MonadLsp config m => m (LanguageContextEnv config)
runLspT :: LanguageContextEnv config -> LspT config m a -> m a
data LanguageContextEnv config
LanguageContextEnv :: !Handlers IO -> !config -> Value -> Either Text config -> !FromServerMessage -> IO () -> !LanguageContextState config -> !ClientCapabilities -> !Maybe FilePath -> LanguageContextEnv config
[resHandlers] :: LanguageContextEnv config -> !Handlers IO
[resParseConfig] :: LanguageContextEnv config -> !config -> Value -> Either Text config
[resSendMessage] :: LanguageContextEnv config -> !FromServerMessage -> IO ()
[resState] :: LanguageContextEnv config -> !LanguageContextState config
[resClientCapabilities] :: LanguageContextEnv config -> !ClientCapabilities
[resRootPath] :: LanguageContextEnv config -> !Maybe FilePath

-- | How to convert two isomorphic data structures between each other.
data m <~> n
Iso :: (forall a. m a -> n a) -> (forall a. n a -> m a) -> (<~>) m n
[forward] :: (<~>) m n -> forall a. m a -> n a
[backward] :: (<~>) m n -> forall a. n a -> m a
getClientCapabilities :: MonadLsp config m => m ClientCapabilities

-- | The current configuration from the client as set via the
--   <tt>initialize</tt> and <tt>workspace/didChangeConfiguration</tt>
--   requests, as well as by calls to <a>setConfig</a>.
getConfig :: MonadLsp config m => m config
setConfig :: MonadLsp config m => config -> m ()
getRootPath :: MonadLsp config m => m (Maybe FilePath)

-- | The current workspace folders, if the client supports workspace
--   folders.
getWorkspaceFolders :: MonadLsp config m => m (Maybe [WorkspaceFolder])
sendRequest :: forall (m :: Method FromServer Request) f config. MonadLsp config f => SServerMethod m -> MessageParams m -> (Either ResponseError (ResponseResult m) -> f ()) -> f (LspId m)
sendNotification :: forall (m :: Method FromServer Notification) f config. MonadLsp config f => SServerMethod m -> MessageParams m -> f ()

-- | Return the <a>VirtualFile</a> associated with a given
--   <a>NormalizedUri</a>, if there is one.
getVirtualFile :: MonadLsp config m => NormalizedUri -> m (Maybe VirtualFile)
getVirtualFiles :: MonadLsp config m => m VFS

-- | Dump the current text for a given VFS file to a temporary file, and
--   return the path to the file.
persistVirtualFile :: MonadLsp config m => LogAction m (WithSeverity VfsLog) -> NormalizedUri -> m (Maybe FilePath)

-- | Given a text document identifier, annotate it with the latest version.
getVersionedTextDoc :: MonadLsp config m => TextDocumentIdentifier -> m VersionedTextDocumentIdentifier

-- | If the contents of a VFS has been dumped to a temporary file, map the
--   temporary file name back to the original one.
reverseFileMap :: MonadLsp config m => m (FilePath -> FilePath)

-- | Take an atomic snapshot of the current state of the virtual file
--   system.
snapshotVirtualFiles :: LanguageContextEnv c -> STM VFS

-- | Aggregate all diagnostics pertaining to a particular version of a
--   document, by source, and sends a
--   <tt>textDocument/publishDiagnostics</tt> notification with the total
--   (limited by the first parameter) whenever it is updated.
publishDiagnostics :: MonadLsp config m => Int -> NormalizedUri -> TextDocumentVersion -> DiagnosticsBySource -> m ()

-- | Remove all diagnostics from a particular source, and send the updates
--   to the client.
flushDiagnosticsBySource :: MonadLsp config m => Int -> Maybe DiagnosticSource -> m ()

-- | Wrapper for reporting progress to the client during a long running
--   task. <a>withProgress</a> <tt>title cancellable f</tt> starts a new
--   progress reporting session, and finishes it once f is completed. f is
--   provided with an update function that allows it to report on the
--   progress during the session. If <tt>cancellable</tt> is
--   <a>Cancellable</a>, <tt>f</tt> will be thrown a
--   <a>ProgressCancelledException</a> if the user cancels the action in
--   progress.
withProgress :: MonadLsp c m => Text -> ProgressCancellable -> ((ProgressAmount -> m ()) -> m a) -> m a

-- | Same as <a>withProgress</a>, but for processes that do not report the
--   precentage complete.
withIndefiniteProgress :: MonadLsp c m => Text -> ProgressCancellable -> m a -> m a

-- | A package indicating the percentage of progress complete and a an
--   optional message to go with it during a <a>withProgress</a>
data ProgressAmount
ProgressAmount :: Maybe UInt -> Maybe Text -> ProgressAmount

-- | Whether or not the user should be able to cancel a
--   <a>withProgress</a>/<a>withIndefiniteProgress</a> session
data ProgressCancellable
Cancellable :: ProgressCancellable
NotCancellable :: ProgressCancellable

-- | Thrown if the user cancels a <a>Cancellable</a>
--   <a>withProgress</a><i><a>withIndefiniteProgress</a></i> session
data ProgressCancelledException

-- | Sends a <tt>client/registerCapability</tt> request and dynamically
--   registers a <a>Method</a> with a <a>Handler</a>. Returns
--   <a>Nothing</a> if the client does not support dynamic registration for
--   the specified method, otherwise a <a>RegistrationToken</a> which can
--   be used to unregister it later.
registerCapability :: forall f t (m :: Method FromClient t) config. MonadLsp config f => SClientMethod m -> RegistrationOptions m -> Handler f m -> f (Maybe (RegistrationToken m))

-- | Sends a <tt>client/unregisterCapability</tt> request and removes the
--   handler for that associated registration.
unregisterCapability :: MonadLsp config f => RegistrationToken m -> f ()
data RegistrationToken (m :: Method FromClient t)

-- | The changes in a workspace edit should be applied from the end of the
--   file toward the start. Sort them into this order.
reverseSortEdit :: WorkspaceEdit -> WorkspaceEdit
